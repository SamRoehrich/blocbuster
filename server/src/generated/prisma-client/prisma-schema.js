module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAthlete {
  count: Int!
}

type AggregateAthleteSchedule {
  count: Int!
}

type AggregateAthleteStats {
  count: Int!
}

type AggregateCoach {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateHeadCoach {
  count: Int!
}

type AggregateLogItem {
  count: Int!
}

type AggregateParent {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateResult {
  count: Int!
}

type AggregateSubTeam {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateTeamSchedule {
  count: Int!
}

type AggregateWorkout {
  count: Int!
}

type Athlete {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  DOB: String
  createdAt: DateTime!
  team: Team
  subTeam: SubTeam
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent!]
  athleteStats: AthleteStats
  athleteSchedule: AthleteSchedule
  logBook(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LogItem!]
  phase: String
}

type AthleteConnection {
  pageInfo: PageInfo!
  edges: [AthleteEdge]!
  aggregate: AggregateAthlete!
}

input AthleteCreateInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  subTeam: SubTeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

input AthleteCreateManyInput {
  create: [AthleteCreateInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateManyWithoutSubTeamInput {
  create: [AthleteCreateWithoutSubTeamInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateManyWithoutTeamInput {
  create: [AthleteCreateWithoutTeamInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateOneInput {
  create: AthleteCreateInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutAthleteScheduleInput {
  create: AthleteCreateWithoutAthleteScheduleInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutAthleteStatsInput {
  create: AthleteCreateWithoutAthleteStatsInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutLogBookInput {
  create: AthleteCreateWithoutLogBookInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutParentsInput {
  create: AthleteCreateWithoutParentsInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateWithoutAthleteScheduleInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  subTeam: SubTeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

input AthleteCreateWithoutAthleteStatsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  subTeam: SubTeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

input AthleteCreateWithoutLogBookInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  subTeam: SubTeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  phase: String
}

input AthleteCreateWithoutParentsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  subTeam: SubTeamCreateOneWithoutAthletesInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

input AthleteCreateWithoutSubTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  team: TeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

input AthleteCreateWithoutTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  DOB: String
  subTeam: SubTeamCreateOneWithoutAthletesInput
  parents: ParentCreateManyWithoutAthleteInput
  athleteStats: AthleteStatsCreateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleCreateOneWithoutAthleteInput
  logBook: LogItemCreateManyWithoutAthleteInput
  phase: String
}

type AthleteEdge {
  node: Athlete!
  cursor: String!
}

enum AthleteOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  DOB_ASC
  DOB_DESC
  createdAt_ASC
  createdAt_DESC
  phase_ASC
  phase_DESC
}

type AthletePreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  DOB: String
  createdAt: DateTime!
  phase: String
}

input AthleteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  DOB: String
  DOB_not: String
  DOB_in: [String!]
  DOB_not_in: [String!]
  DOB_lt: String
  DOB_lte: String
  DOB_gt: String
  DOB_gte: String
  DOB_contains: String
  DOB_not_contains: String
  DOB_starts_with: String
  DOB_not_starts_with: String
  DOB_ends_with: String
  DOB_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  AND: [AthleteScalarWhereInput!]
  OR: [AthleteScalarWhereInput!]
  NOT: [AthleteScalarWhereInput!]
}

type AthleteSchedule {
  id: ID!
  createdBy: Coach!
  createdAt: DateTime!
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  athlete: Athlete!
}

type AthleteScheduleConnection {
  pageInfo: PageInfo!
  edges: [AthleteScheduleEdge]!
  aggregate: AggregateAthleteSchedule!
}

input AthleteScheduleCreateInput {
  id: ID
  createdBy: CoachCreateOneInput!
  library: WorkoutCreateManyInput
  athlete: AthleteCreateOneWithoutAthleteScheduleInput!
}

input AthleteScheduleCreateOneWithoutAthleteInput {
  create: AthleteScheduleCreateWithoutAthleteInput
  connect: AthleteScheduleWhereUniqueInput
}

input AthleteScheduleCreateWithoutAthleteInput {
  id: ID
  createdBy: CoachCreateOneInput!
  library: WorkoutCreateManyInput
}

type AthleteScheduleEdge {
  node: AthleteSchedule!
  cursor: String!
}

enum AthleteScheduleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type AthleteSchedulePreviousValues {
  id: ID!
  createdAt: DateTime!
}

type AthleteScheduleSubscriptionPayload {
  mutation: MutationType!
  node: AthleteSchedule
  updatedFields: [String!]
  previousValues: AthleteSchedulePreviousValues
}

input AthleteScheduleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AthleteScheduleWhereInput
  AND: [AthleteScheduleSubscriptionWhereInput!]
  OR: [AthleteScheduleSubscriptionWhereInput!]
  NOT: [AthleteScheduleSubscriptionWhereInput!]
}

input AthleteScheduleUpdateInput {
  createdBy: CoachUpdateOneRequiredInput
  library: WorkoutUpdateManyInput
  athlete: AthleteUpdateOneRequiredWithoutAthleteScheduleInput
}

input AthleteScheduleUpdateOneWithoutAthleteInput {
  create: AthleteScheduleCreateWithoutAthleteInput
  update: AthleteScheduleUpdateWithoutAthleteDataInput
  upsert: AthleteScheduleUpsertWithoutAthleteInput
  delete: Boolean
  disconnect: Boolean
  connect: AthleteScheduleWhereUniqueInput
}

input AthleteScheduleUpdateWithoutAthleteDataInput {
  createdBy: CoachUpdateOneRequiredInput
  library: WorkoutUpdateManyInput
}

input AthleteScheduleUpsertWithoutAthleteInput {
  update: AthleteScheduleUpdateWithoutAthleteDataInput!
  create: AthleteScheduleCreateWithoutAthleteInput!
}

input AthleteScheduleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdBy: CoachWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  athlete: AthleteWhereInput
  AND: [AthleteScheduleWhereInput!]
  OR: [AthleteScheduleWhereInput!]
  NOT: [AthleteScheduleWhereInput!]
}

input AthleteScheduleWhereUniqueInput {
  id: ID
}

type AthleteStats {
  id: ID!
  athlete: Athlete!
  createdAt: DateTime!
  createdBy: Coach
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float
  goalVGrade: Int!
  goalSportGrade: String!
}

type AthleteStatsConnection {
  pageInfo: PageInfo!
  edges: [AthleteStatsEdge]!
  aggregate: AggregateAthleteStats!
}

input AthleteStatsCreateInput {
  id: ID
  athlete: AthleteCreateOneWithoutAthleteStatsInput!
  createdBy: CoachCreateOneInput
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float
  goalVGrade: Int!
  goalSportGrade: String!
}

input AthleteStatsCreateOneWithoutAthleteInput {
  create: AthleteStatsCreateWithoutAthleteInput
  connect: AthleteStatsWhereUniqueInput
}

input AthleteStatsCreateWithoutAthleteInput {
  id: ID
  createdBy: CoachCreateOneInput
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float
  goalVGrade: Int!
  goalSportGrade: String!
}

type AthleteStatsEdge {
  node: AthleteStats!
  cursor: String!
}

enum AthleteStatsOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  apeIndex_ASC
  apeIndex_DESC
  height_ASC
  height_DESC
  weight_ASC
  weight_DESC
  maxVGrade_ASC
  maxVGrade_DESC
  maxSportGrade_ASC
  maxSportGrade_DESC
  maxEdgeLoad_ASC
  maxEdgeLoad_DESC
  maxEdgeTestSize_ASC
  maxEdgeTestSize_DESC
  SWREdge_ASC
  SWREdge_DESC
  maxPullLoad_ASC
  maxPullLoad_DESC
  SWRBar_ASC
  SWRBar_DESC
  oneArmHangLoadLeft_ASC
  oneArmHangLoadLeft_DESC
  oneArmHangLoadRight_ASC
  oneArmHangLoadRight_DESC
  oneArmHangSWR_ASC
  oneArmHangSWR_DESC
  goalVGrade_ASC
  goalVGrade_DESC
  goalSportGrade_ASC
  goalSportGrade_DESC
}

type AthleteStatsPreviousValues {
  id: ID!
  createdAt: DateTime!
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float
  goalVGrade: Int!
  goalSportGrade: String!
}

type AthleteStatsSubscriptionPayload {
  mutation: MutationType!
  node: AthleteStats
  updatedFields: [String!]
  previousValues: AthleteStatsPreviousValues
}

input AthleteStatsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AthleteStatsWhereInput
  AND: [AthleteStatsSubscriptionWhereInput!]
  OR: [AthleteStatsSubscriptionWhereInput!]
  NOT: [AthleteStatsSubscriptionWhereInput!]
}

input AthleteStatsUpdateInput {
  athlete: AthleteUpdateOneRequiredWithoutAthleteStatsInput
  createdBy: CoachUpdateOneInput
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateManyMutationInput {
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateOneWithoutAthleteInput {
  create: AthleteStatsCreateWithoutAthleteInput
  update: AthleteStatsUpdateWithoutAthleteDataInput
  upsert: AthleteStatsUpsertWithoutAthleteInput
  delete: Boolean
  disconnect: Boolean
  connect: AthleteStatsWhereUniqueInput
}

input AthleteStatsUpdateWithoutAthleteDataInput {
  createdBy: CoachUpdateOneInput
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpsertWithoutAthleteInput {
  update: AthleteStatsUpdateWithoutAthleteDataInput!
  create: AthleteStatsCreateWithoutAthleteInput!
}

input AthleteStatsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  athlete: AthleteWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  createdBy: CoachWhereInput
  apeIndex: Int
  apeIndex_not: Int
  apeIndex_in: [Int!]
  apeIndex_not_in: [Int!]
  apeIndex_lt: Int
  apeIndex_lte: Int
  apeIndex_gt: Int
  apeIndex_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  maxVGrade: Int
  maxVGrade_not: Int
  maxVGrade_in: [Int!]
  maxVGrade_not_in: [Int!]
  maxVGrade_lt: Int
  maxVGrade_lte: Int
  maxVGrade_gt: Int
  maxVGrade_gte: Int
  maxSportGrade: String
  maxSportGrade_not: String
  maxSportGrade_in: [String!]
  maxSportGrade_not_in: [String!]
  maxSportGrade_lt: String
  maxSportGrade_lte: String
  maxSportGrade_gt: String
  maxSportGrade_gte: String
  maxSportGrade_contains: String
  maxSportGrade_not_contains: String
  maxSportGrade_starts_with: String
  maxSportGrade_not_starts_with: String
  maxSportGrade_ends_with: String
  maxSportGrade_not_ends_with: String
  maxEdgeLoad: Int
  maxEdgeLoad_not: Int
  maxEdgeLoad_in: [Int!]
  maxEdgeLoad_not_in: [Int!]
  maxEdgeLoad_lt: Int
  maxEdgeLoad_lte: Int
  maxEdgeLoad_gt: Int
  maxEdgeLoad_gte: Int
  maxEdgeTestSize: Int
  maxEdgeTestSize_not: Int
  maxEdgeTestSize_in: [Int!]
  maxEdgeTestSize_not_in: [Int!]
  maxEdgeTestSize_lt: Int
  maxEdgeTestSize_lte: Int
  maxEdgeTestSize_gt: Int
  maxEdgeTestSize_gte: Int
  SWREdge: Float
  SWREdge_not: Float
  SWREdge_in: [Float!]
  SWREdge_not_in: [Float!]
  SWREdge_lt: Float
  SWREdge_lte: Float
  SWREdge_gt: Float
  SWREdge_gte: Float
  maxPullLoad: Int
  maxPullLoad_not: Int
  maxPullLoad_in: [Int!]
  maxPullLoad_not_in: [Int!]
  maxPullLoad_lt: Int
  maxPullLoad_lte: Int
  maxPullLoad_gt: Int
  maxPullLoad_gte: Int
  SWRBar: Float
  SWRBar_not: Float
  SWRBar_in: [Float!]
  SWRBar_not_in: [Float!]
  SWRBar_lt: Float
  SWRBar_lte: Float
  SWRBar_gt: Float
  SWRBar_gte: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadLeft_not: Int
  oneArmHangLoadLeft_in: [Int!]
  oneArmHangLoadLeft_not_in: [Int!]
  oneArmHangLoadLeft_lt: Int
  oneArmHangLoadLeft_lte: Int
  oneArmHangLoadLeft_gt: Int
  oneArmHangLoadLeft_gte: Int
  oneArmHangLoadRight: Int
  oneArmHangLoadRight_not: Int
  oneArmHangLoadRight_in: [Int!]
  oneArmHangLoadRight_not_in: [Int!]
  oneArmHangLoadRight_lt: Int
  oneArmHangLoadRight_lte: Int
  oneArmHangLoadRight_gt: Int
  oneArmHangLoadRight_gte: Int
  oneArmHangSWR: Float
  oneArmHangSWR_not: Float
  oneArmHangSWR_in: [Float!]
  oneArmHangSWR_not_in: [Float!]
  oneArmHangSWR_lt: Float
  oneArmHangSWR_lte: Float
  oneArmHangSWR_gt: Float
  oneArmHangSWR_gte: Float
  goalVGrade: Int
  goalVGrade_not: Int
  goalVGrade_in: [Int!]
  goalVGrade_not_in: [Int!]
  goalVGrade_lt: Int
  goalVGrade_lte: Int
  goalVGrade_gt: Int
  goalVGrade_gte: Int
  goalSportGrade: String
  goalSportGrade_not: String
  goalSportGrade_in: [String!]
  goalSportGrade_not_in: [String!]
  goalSportGrade_lt: String
  goalSportGrade_lte: String
  goalSportGrade_gt: String
  goalSportGrade_gte: String
  goalSportGrade_contains: String
  goalSportGrade_not_contains: String
  goalSportGrade_starts_with: String
  goalSportGrade_not_starts_with: String
  goalSportGrade_ends_with: String
  goalSportGrade_not_ends_with: String
  AND: [AthleteStatsWhereInput!]
  OR: [AthleteStatsWhereInput!]
  NOT: [AthleteStatsWhereInput!]
}

input AthleteStatsWhereUniqueInput {
  id: ID
}

type AthleteSubscriptionPayload {
  mutation: MutationType!
  node: Athlete
  updatedFields: [String!]
  previousValues: AthletePreviousValues
}

input AthleteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AthleteWhereInput
  AND: [AthleteSubscriptionWhereInput!]
  OR: [AthleteSubscriptionWhereInput!]
  NOT: [AthleteSubscriptionWhereInput!]
}

input AthleteUpdateDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateManyDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  phase: String
}

input AthleteUpdateManyInput {
  create: [AthleteCreateInput!]
  update: [AthleteUpdateWithWhereUniqueNestedInput!]
  upsert: [AthleteUpsertWithWhereUniqueNestedInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  DOB: String
  phase: String
}

input AthleteUpdateManyWithoutSubTeamInput {
  create: [AthleteCreateWithoutSubTeamInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  update: [AthleteUpdateWithWhereUniqueWithoutSubTeamInput!]
  upsert: [AthleteUpsertWithWhereUniqueWithoutSubTeamInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyWithoutTeamInput {
  create: [AthleteCreateWithoutTeamInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  update: [AthleteUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [AthleteUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyWithWhereNestedInput {
  where: AthleteScalarWhereInput!
  data: AthleteUpdateManyDataInput!
}

input AthleteUpdateOneInput {
  create: AthleteCreateInput
  update: AthleteUpdateDataInput
  upsert: AthleteUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredInput {
  create: AthleteCreateInput
  update: AthleteUpdateDataInput
  upsert: AthleteUpsertNestedInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredWithoutAthleteScheduleInput {
  create: AthleteCreateWithoutAthleteScheduleInput
  update: AthleteUpdateWithoutAthleteScheduleDataInput
  upsert: AthleteUpsertWithoutAthleteScheduleInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredWithoutAthleteStatsInput {
  create: AthleteCreateWithoutAthleteStatsInput
  update: AthleteUpdateWithoutAthleteStatsDataInput
  upsert: AthleteUpsertWithoutAthleteStatsInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredWithoutLogBookInput {
  create: AthleteCreateWithoutLogBookInput
  update: AthleteUpdateWithoutLogBookDataInput
  upsert: AthleteUpsertWithoutLogBookInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneWithoutParentsInput {
  create: AthleteCreateWithoutParentsInput
  update: AthleteUpdateWithoutParentsDataInput
  upsert: AthleteUpsertWithoutParentsInput
  delete: Boolean
  disconnect: Boolean
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateWithoutAthleteScheduleDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithoutAthleteStatsDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithoutLogBookDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithoutParentsDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithoutSubTeamDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  team: TeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithoutTeamDataInput {
  fullName: String
  email: String
  password: String
  DOB: String
  subTeam: SubTeamUpdateOneWithoutAthletesInput
  parents: ParentUpdateManyWithoutAthleteInput
  athleteStats: AthleteStatsUpdateOneWithoutAthleteInput
  athleteSchedule: AthleteScheduleUpdateOneWithoutAthleteInput
  logBook: LogItemUpdateManyWithoutAthleteInput
  phase: String
}

input AthleteUpdateWithWhereUniqueNestedInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateDataInput!
}

input AthleteUpdateWithWhereUniqueWithoutSubTeamInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateWithoutSubTeamDataInput!
}

input AthleteUpdateWithWhereUniqueWithoutTeamInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateWithoutTeamDataInput!
}

input AthleteUpsertNestedInput {
  update: AthleteUpdateDataInput!
  create: AthleteCreateInput!
}

input AthleteUpsertWithoutAthleteScheduleInput {
  update: AthleteUpdateWithoutAthleteScheduleDataInput!
  create: AthleteCreateWithoutAthleteScheduleInput!
}

input AthleteUpsertWithoutAthleteStatsInput {
  update: AthleteUpdateWithoutAthleteStatsDataInput!
  create: AthleteCreateWithoutAthleteStatsInput!
}

input AthleteUpsertWithoutLogBookInput {
  update: AthleteUpdateWithoutLogBookDataInput!
  create: AthleteCreateWithoutLogBookInput!
}

input AthleteUpsertWithoutParentsInput {
  update: AthleteUpdateWithoutParentsDataInput!
  create: AthleteCreateWithoutParentsInput!
}

input AthleteUpsertWithWhereUniqueNestedInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateDataInput!
  create: AthleteCreateInput!
}

input AthleteUpsertWithWhereUniqueWithoutSubTeamInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateWithoutSubTeamDataInput!
  create: AthleteCreateWithoutSubTeamInput!
}

input AthleteUpsertWithWhereUniqueWithoutTeamInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateWithoutTeamDataInput!
  create: AthleteCreateWithoutTeamInput!
}

input AthleteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  DOB: String
  DOB_not: String
  DOB_in: [String!]
  DOB_not_in: [String!]
  DOB_lt: String
  DOB_lte: String
  DOB_gt: String
  DOB_gte: String
  DOB_contains: String
  DOB_not_contains: String
  DOB_starts_with: String
  DOB_not_starts_with: String
  DOB_ends_with: String
  DOB_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  team: TeamWhereInput
  subTeam: SubTeamWhereInput
  parents_every: ParentWhereInput
  parents_some: ParentWhereInput
  parents_none: ParentWhereInput
  athleteStats: AthleteStatsWhereInput
  athleteSchedule: AthleteScheduleWhereInput
  logBook_every: LogItemWhereInput
  logBook_some: LogItemWhereInput
  logBook_none: LogItemWhereInput
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  AND: [AthleteWhereInput!]
  OR: [AthleteWhereInput!]
  NOT: [AthleteWhereInput!]
}

input AthleteWhereUniqueInput {
  id: ID
  fullName: String
  email: String
}

type BatchPayload {
  count: Long!
}

type Coach {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  createdAt: DateTime!
  team: Team
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam!]
}

type CoachConnection {
  pageInfo: PageInfo!
  edges: [CoachEdge]!
  aggregate: AggregateCoach!
}

input CoachCreateInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  team: TeamCreateOneWithoutCoachesInput
  subTeams: SubTeamCreateManyWithoutCoachesInput
}

input CoachCreateManyWithoutSubTeamsInput {
  create: [CoachCreateWithoutSubTeamsInput!]
  connect: [CoachWhereUniqueInput!]
}

input CoachCreateManyWithoutTeamInput {
  create: [CoachCreateWithoutTeamInput!]
  connect: [CoachWhereUniqueInput!]
}

input CoachCreateOneInput {
  create: CoachCreateInput
  connect: CoachWhereUniqueInput
}

input CoachCreateWithoutSubTeamsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  team: TeamCreateOneWithoutCoachesInput
}

input CoachCreateWithoutTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  subTeams: SubTeamCreateManyWithoutCoachesInput
}

type CoachEdge {
  node: Coach!
  cursor: String!
}

enum CoachOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
}

type CoachPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  createdAt: DateTime!
}

input CoachScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [CoachScalarWhereInput!]
  OR: [CoachScalarWhereInput!]
  NOT: [CoachScalarWhereInput!]
}

type CoachSubscriptionPayload {
  mutation: MutationType!
  node: Coach
  updatedFields: [String!]
  previousValues: CoachPreviousValues
}

input CoachSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CoachWhereInput
  AND: [CoachSubscriptionWhereInput!]
  OR: [CoachSubscriptionWhereInput!]
  NOT: [CoachSubscriptionWhereInput!]
}

input CoachUpdateDataInput {
  fullName: String
  email: String
  password: String
  team: TeamUpdateOneWithoutCoachesInput
  subTeams: SubTeamUpdateManyWithoutCoachesInput
}

input CoachUpdateInput {
  fullName: String
  email: String
  password: String
  team: TeamUpdateOneWithoutCoachesInput
  subTeams: SubTeamUpdateManyWithoutCoachesInput
}

input CoachUpdateManyDataInput {
  fullName: String
  email: String
  password: String
}

input CoachUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
}

input CoachUpdateManyWithoutSubTeamsInput {
  create: [CoachCreateWithoutSubTeamsInput!]
  delete: [CoachWhereUniqueInput!]
  connect: [CoachWhereUniqueInput!]
  set: [CoachWhereUniqueInput!]
  disconnect: [CoachWhereUniqueInput!]
  update: [CoachUpdateWithWhereUniqueWithoutSubTeamsInput!]
  upsert: [CoachUpsertWithWhereUniqueWithoutSubTeamsInput!]
  deleteMany: [CoachScalarWhereInput!]
  updateMany: [CoachUpdateManyWithWhereNestedInput!]
}

input CoachUpdateManyWithoutTeamInput {
  create: [CoachCreateWithoutTeamInput!]
  delete: [CoachWhereUniqueInput!]
  connect: [CoachWhereUniqueInput!]
  set: [CoachWhereUniqueInput!]
  disconnect: [CoachWhereUniqueInput!]
  update: [CoachUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [CoachUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [CoachScalarWhereInput!]
  updateMany: [CoachUpdateManyWithWhereNestedInput!]
}

input CoachUpdateManyWithWhereNestedInput {
  where: CoachScalarWhereInput!
  data: CoachUpdateManyDataInput!
}

input CoachUpdateOneInput {
  create: CoachCreateInput
  update: CoachUpdateDataInput
  upsert: CoachUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CoachWhereUniqueInput
}

input CoachUpdateOneRequiredInput {
  create: CoachCreateInput
  update: CoachUpdateDataInput
  upsert: CoachUpsertNestedInput
  connect: CoachWhereUniqueInput
}

input CoachUpdateWithoutSubTeamsDataInput {
  fullName: String
  email: String
  password: String
  team: TeamUpdateOneWithoutCoachesInput
}

input CoachUpdateWithoutTeamDataInput {
  fullName: String
  email: String
  password: String
  subTeams: SubTeamUpdateManyWithoutCoachesInput
}

input CoachUpdateWithWhereUniqueWithoutSubTeamsInput {
  where: CoachWhereUniqueInput!
  data: CoachUpdateWithoutSubTeamsDataInput!
}

input CoachUpdateWithWhereUniqueWithoutTeamInput {
  where: CoachWhereUniqueInput!
  data: CoachUpdateWithoutTeamDataInput!
}

input CoachUpsertNestedInput {
  update: CoachUpdateDataInput!
  create: CoachCreateInput!
}

input CoachUpsertWithWhereUniqueWithoutSubTeamsInput {
  where: CoachWhereUniqueInput!
  update: CoachUpdateWithoutSubTeamsDataInput!
  create: CoachCreateWithoutSubTeamsInput!
}

input CoachUpsertWithWhereUniqueWithoutTeamInput {
  where: CoachWhereUniqueInput!
  update: CoachUpdateWithoutTeamDataInput!
  create: CoachCreateWithoutTeamInput!
}

input CoachWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  team: TeamWhereInput
  subTeams_every: SubTeamWhereInput
  subTeams_some: SubTeamWhereInput
  subTeams_none: SubTeamWhereInput
  AND: [CoachWhereInput!]
  OR: [CoachWhereInput!]
  NOT: [CoachWhereInput!]
}

input CoachWhereUniqueInput {
  id: ID
  email: String
}

type Comment {
  id: ID!
  post: Post!
  coach: Coach
  athlete: Athlete
  content: String!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  post: PostCreateOneWithoutCommentsInput!
  coach: CoachCreateOneInput
  athlete: AthleteCreateOneInput
  content: String!
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutPostInput {
  id: ID
  coach: CoachCreateOneInput
  athlete: AthleteCreateOneInput
  content: String!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type CommentPreviousValues {
  id: ID!
  content: String!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
  coach: CoachUpdateOneInput
  athlete: AthleteUpdateOneInput
  content: String
}

input CommentUpdateManyDataInput {
  content: String
}

input CommentUpdateManyMutationInput {
  content: String
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutPostDataInput {
  coach: CoachUpdateOneInput
  athlete: AthleteUpdateOneInput
  content: String
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  post: PostWhereInput
  coach: CoachWhereInput
  athlete: AthleteWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type HeadCoach {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  createdAt: DateTime!
  team: Team
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam!]
}

type HeadCoachConnection {
  pageInfo: PageInfo!
  edges: [HeadCoachEdge]!
  aggregate: AggregateHeadCoach!
}

input HeadCoachCreateInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  team: TeamCreateOneWithoutHeadCoachInput
  subTeams: SubTeamCreateManyWithoutHeadCoachInput
}

input HeadCoachCreateOneWithoutSubTeamsInput {
  create: HeadCoachCreateWithoutSubTeamsInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachCreateOneWithoutTeamInput {
  create: HeadCoachCreateWithoutTeamInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachCreateWithoutSubTeamsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  team: TeamCreateOneWithoutHeadCoachInput
}

input HeadCoachCreateWithoutTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  subTeams: SubTeamCreateManyWithoutHeadCoachInput
}

type HeadCoachEdge {
  node: HeadCoach!
  cursor: String!
}

enum HeadCoachOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
}

type HeadCoachPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  createdAt: DateTime!
}

type HeadCoachSubscriptionPayload {
  mutation: MutationType!
  node: HeadCoach
  updatedFields: [String!]
  previousValues: HeadCoachPreviousValues
}

input HeadCoachSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HeadCoachWhereInput
  AND: [HeadCoachSubscriptionWhereInput!]
  OR: [HeadCoachSubscriptionWhereInput!]
  NOT: [HeadCoachSubscriptionWhereInput!]
}

input HeadCoachUpdateInput {
  fullName: String
  email: String
  password: String
  team: TeamUpdateOneWithoutHeadCoachInput
  subTeams: SubTeamUpdateManyWithoutHeadCoachInput
}

input HeadCoachUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
}

input HeadCoachUpdateOneRequiredWithoutSubTeamsInput {
  create: HeadCoachCreateWithoutSubTeamsInput
  update: HeadCoachUpdateWithoutSubTeamsDataInput
  upsert: HeadCoachUpsertWithoutSubTeamsInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachUpdateOneWithoutTeamInput {
  create: HeadCoachCreateWithoutTeamInput
  update: HeadCoachUpdateWithoutTeamDataInput
  upsert: HeadCoachUpsertWithoutTeamInput
  delete: Boolean
  disconnect: Boolean
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachUpdateWithoutSubTeamsDataInput {
  fullName: String
  email: String
  password: String
  team: TeamUpdateOneWithoutHeadCoachInput
}

input HeadCoachUpdateWithoutTeamDataInput {
  fullName: String
  email: String
  password: String
  subTeams: SubTeamUpdateManyWithoutHeadCoachInput
}

input HeadCoachUpsertWithoutSubTeamsInput {
  update: HeadCoachUpdateWithoutSubTeamsDataInput!
  create: HeadCoachCreateWithoutSubTeamsInput!
}

input HeadCoachUpsertWithoutTeamInput {
  update: HeadCoachUpdateWithoutTeamDataInput!
  create: HeadCoachCreateWithoutTeamInput!
}

input HeadCoachWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  team: TeamWhereInput
  subTeams_every: SubTeamWhereInput
  subTeams_some: SubTeamWhereInput
  subTeams_none: SubTeamWhereInput
  AND: [HeadCoachWhereInput!]
  OR: [HeadCoachWhereInput!]
  NOT: [HeadCoachWhereInput!]
}

input HeadCoachWhereUniqueInput {
  id: ID
  email: String
}

type LogItem {
  athlete: Athlete!
  id: ID!
  createdAt: DateTime!
  title: String!
  description: String!
  results: Result!
  comment: String
}

type LogItemConnection {
  pageInfo: PageInfo!
  edges: [LogItemEdge]!
  aggregate: AggregateLogItem!
}

input LogItemCreateInput {
  athlete: AthleteCreateOneWithoutLogBookInput!
  id: ID
  title: String!
  description: String!
  results: ResultCreateOneInput!
  comment: String
}

input LogItemCreateManyWithoutAthleteInput {
  create: [LogItemCreateWithoutAthleteInput!]
  connect: [LogItemWhereUniqueInput!]
}

input LogItemCreateWithoutAthleteInput {
  id: ID
  title: String!
  description: String!
  results: ResultCreateOneInput!
  comment: String
}

type LogItemEdge {
  node: LogItem!
  cursor: String!
}

enum LogItemOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  comment_ASC
  comment_DESC
}

type LogItemPreviousValues {
  id: ID!
  createdAt: DateTime!
  title: String!
  description: String!
  comment: String
}

input LogItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [LogItemScalarWhereInput!]
  OR: [LogItemScalarWhereInput!]
  NOT: [LogItemScalarWhereInput!]
}

type LogItemSubscriptionPayload {
  mutation: MutationType!
  node: LogItem
  updatedFields: [String!]
  previousValues: LogItemPreviousValues
}

input LogItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogItemWhereInput
  AND: [LogItemSubscriptionWhereInput!]
  OR: [LogItemSubscriptionWhereInput!]
  NOT: [LogItemSubscriptionWhereInput!]
}

input LogItemUpdateInput {
  athlete: AthleteUpdateOneRequiredWithoutLogBookInput
  title: String
  description: String
  results: ResultUpdateOneRequiredInput
  comment: String
}

input LogItemUpdateManyDataInput {
  title: String
  description: String
  comment: String
}

input LogItemUpdateManyMutationInput {
  title: String
  description: String
  comment: String
}

input LogItemUpdateManyWithoutAthleteInput {
  create: [LogItemCreateWithoutAthleteInput!]
  delete: [LogItemWhereUniqueInput!]
  connect: [LogItemWhereUniqueInput!]
  set: [LogItemWhereUniqueInput!]
  disconnect: [LogItemWhereUniqueInput!]
  update: [LogItemUpdateWithWhereUniqueWithoutAthleteInput!]
  upsert: [LogItemUpsertWithWhereUniqueWithoutAthleteInput!]
  deleteMany: [LogItemScalarWhereInput!]
  updateMany: [LogItemUpdateManyWithWhereNestedInput!]
}

input LogItemUpdateManyWithWhereNestedInput {
  where: LogItemScalarWhereInput!
  data: LogItemUpdateManyDataInput!
}

input LogItemUpdateWithoutAthleteDataInput {
  title: String
  description: String
  results: ResultUpdateOneRequiredInput
  comment: String
}

input LogItemUpdateWithWhereUniqueWithoutAthleteInput {
  where: LogItemWhereUniqueInput!
  data: LogItemUpdateWithoutAthleteDataInput!
}

input LogItemUpsertWithWhereUniqueWithoutAthleteInput {
  where: LogItemWhereUniqueInput!
  update: LogItemUpdateWithoutAthleteDataInput!
  create: LogItemCreateWithoutAthleteInput!
}

input LogItemWhereInput {
  athlete: AthleteWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  results: ResultWhereInput
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [LogItemWhereInput!]
  OR: [LogItemWhereInput!]
  NOT: [LogItemWhereInput!]
}

input LogItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAthlete(data: AthleteCreateInput!): Athlete!
  updateAthlete(data: AthleteUpdateInput!, where: AthleteWhereUniqueInput!): Athlete
  updateManyAthletes(data: AthleteUpdateManyMutationInput!, where: AthleteWhereInput): BatchPayload!
  upsertAthlete(where: AthleteWhereUniqueInput!, create: AthleteCreateInput!, update: AthleteUpdateInput!): Athlete!
  deleteAthlete(where: AthleteWhereUniqueInput!): Athlete
  deleteManyAthletes(where: AthleteWhereInput): BatchPayload!
  createAthleteSchedule(data: AthleteScheduleCreateInput!): AthleteSchedule!
  updateAthleteSchedule(data: AthleteScheduleUpdateInput!, where: AthleteScheduleWhereUniqueInput!): AthleteSchedule
  upsertAthleteSchedule(where: AthleteScheduleWhereUniqueInput!, create: AthleteScheduleCreateInput!, update: AthleteScheduleUpdateInput!): AthleteSchedule!
  deleteAthleteSchedule(where: AthleteScheduleWhereUniqueInput!): AthleteSchedule
  deleteManyAthleteSchedules(where: AthleteScheduleWhereInput): BatchPayload!
  createAthleteStats(data: AthleteStatsCreateInput!): AthleteStats!
  updateAthleteStats(data: AthleteStatsUpdateInput!, where: AthleteStatsWhereUniqueInput!): AthleteStats
  updateManyAthleteStatses(data: AthleteStatsUpdateManyMutationInput!, where: AthleteStatsWhereInput): BatchPayload!
  upsertAthleteStats(where: AthleteStatsWhereUniqueInput!, create: AthleteStatsCreateInput!, update: AthleteStatsUpdateInput!): AthleteStats!
  deleteAthleteStats(where: AthleteStatsWhereUniqueInput!): AthleteStats
  deleteManyAthleteStatses(where: AthleteStatsWhereInput): BatchPayload!
  createCoach(data: CoachCreateInput!): Coach!
  updateCoach(data: CoachUpdateInput!, where: CoachWhereUniqueInput!): Coach
  updateManyCoaches(data: CoachUpdateManyMutationInput!, where: CoachWhereInput): BatchPayload!
  upsertCoach(where: CoachWhereUniqueInput!, create: CoachCreateInput!, update: CoachUpdateInput!): Coach!
  deleteCoach(where: CoachWhereUniqueInput!): Coach
  deleteManyCoaches(where: CoachWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createHeadCoach(data: HeadCoachCreateInput!): HeadCoach!
  updateHeadCoach(data: HeadCoachUpdateInput!, where: HeadCoachWhereUniqueInput!): HeadCoach
  updateManyHeadCoaches(data: HeadCoachUpdateManyMutationInput!, where: HeadCoachWhereInput): BatchPayload!
  upsertHeadCoach(where: HeadCoachWhereUniqueInput!, create: HeadCoachCreateInput!, update: HeadCoachUpdateInput!): HeadCoach!
  deleteHeadCoach(where: HeadCoachWhereUniqueInput!): HeadCoach
  deleteManyHeadCoaches(where: HeadCoachWhereInput): BatchPayload!
  createLogItem(data: LogItemCreateInput!): LogItem!
  updateLogItem(data: LogItemUpdateInput!, where: LogItemWhereUniqueInput!): LogItem
  updateManyLogItems(data: LogItemUpdateManyMutationInput!, where: LogItemWhereInput): BatchPayload!
  upsertLogItem(where: LogItemWhereUniqueInput!, create: LogItemCreateInput!, update: LogItemUpdateInput!): LogItem!
  deleteLogItem(where: LogItemWhereUniqueInput!): LogItem
  deleteManyLogItems(where: LogItemWhereInput): BatchPayload!
  createParent(data: ParentCreateInput!): Parent!
  updateParent(data: ParentUpdateInput!, where: ParentWhereUniqueInput!): Parent
  updateManyParents(data: ParentUpdateManyMutationInput!, where: ParentWhereInput): BatchPayload!
  upsertParent(where: ParentWhereUniqueInput!, create: ParentCreateInput!, update: ParentUpdateInput!): Parent!
  deleteParent(where: ParentWhereUniqueInput!): Parent
  deleteManyParents(where: ParentWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createResult(data: ResultCreateInput!): Result!
  updateResult(data: ResultUpdateInput!, where: ResultWhereUniqueInput!): Result
  updateManyResults(data: ResultUpdateManyMutationInput!, where: ResultWhereInput): BatchPayload!
  upsertResult(where: ResultWhereUniqueInput!, create: ResultCreateInput!, update: ResultUpdateInput!): Result!
  deleteResult(where: ResultWhereUniqueInput!): Result
  deleteManyResults(where: ResultWhereInput): BatchPayload!
  createSubTeam(data: SubTeamCreateInput!): SubTeam!
  updateSubTeam(data: SubTeamUpdateInput!, where: SubTeamWhereUniqueInput!): SubTeam
  updateManySubTeams(data: SubTeamUpdateManyMutationInput!, where: SubTeamWhereInput): BatchPayload!
  upsertSubTeam(where: SubTeamWhereUniqueInput!, create: SubTeamCreateInput!, update: SubTeamUpdateInput!): SubTeam!
  deleteSubTeam(where: SubTeamWhereUniqueInput!): SubTeam
  deleteManySubTeams(where: SubTeamWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createTeamSchedule(data: TeamScheduleCreateInput!): TeamSchedule!
  updateTeamSchedule(data: TeamScheduleUpdateInput!, where: TeamScheduleWhereUniqueInput!): TeamSchedule
  upsertTeamSchedule(where: TeamScheduleWhereUniqueInput!, create: TeamScheduleCreateInput!, update: TeamScheduleUpdateInput!): TeamSchedule!
  deleteTeamSchedule(where: TeamScheduleWhereUniqueInput!): TeamSchedule
  deleteManyTeamSchedules(where: TeamScheduleWhereInput): BatchPayload!
  createWorkout(data: WorkoutCreateInput!): Workout!
  updateWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateManyWorkouts(data: WorkoutUpdateManyMutationInput!, where: WorkoutWhereInput): BatchPayload!
  upsertWorkout(where: WorkoutWhereUniqueInput!, create: WorkoutCreateInput!, update: WorkoutUpdateInput!): Workout!
  deleteWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteManyWorkouts(where: WorkoutWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Parent {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  phoneNumber: String!
  team: Team!
  athlete: Athlete
}

type ParentConnection {
  pageInfo: PageInfo!
  edges: [ParentEdge]!
  aggregate: AggregateParent!
}

input ParentCreateInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  phoneNumber: String!
  team: TeamCreateOneInput!
  athlete: AthleteCreateOneWithoutParentsInput
}

input ParentCreateManyWithoutAthleteInput {
  create: [ParentCreateWithoutAthleteInput!]
  connect: [ParentWhereUniqueInput!]
}

input ParentCreateWithoutAthleteInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  phoneNumber: String!
  team: TeamCreateOneInput!
}

type ParentEdge {
  node: Parent!
  cursor: String!
}

enum ParentOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phoneNumber_ASC
  phoneNumber_DESC
}

type ParentPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  phoneNumber: String!
}

input ParentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  AND: [ParentScalarWhereInput!]
  OR: [ParentScalarWhereInput!]
  NOT: [ParentScalarWhereInput!]
}

type ParentSubscriptionPayload {
  mutation: MutationType!
  node: Parent
  updatedFields: [String!]
  previousValues: ParentPreviousValues
}

input ParentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParentWhereInput
  AND: [ParentSubscriptionWhereInput!]
  OR: [ParentSubscriptionWhereInput!]
  NOT: [ParentSubscriptionWhereInput!]
}

input ParentUpdateInput {
  fullName: String
  email: String
  password: String
  phoneNumber: String
  team: TeamUpdateOneRequiredInput
  athlete: AthleteUpdateOneWithoutParentsInput
}

input ParentUpdateManyDataInput {
  fullName: String
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateManyWithoutAthleteInput {
  create: [ParentCreateWithoutAthleteInput!]
  delete: [ParentWhereUniqueInput!]
  connect: [ParentWhereUniqueInput!]
  set: [ParentWhereUniqueInput!]
  disconnect: [ParentWhereUniqueInput!]
  update: [ParentUpdateWithWhereUniqueWithoutAthleteInput!]
  upsert: [ParentUpsertWithWhereUniqueWithoutAthleteInput!]
  deleteMany: [ParentScalarWhereInput!]
  updateMany: [ParentUpdateManyWithWhereNestedInput!]
}

input ParentUpdateManyWithWhereNestedInput {
  where: ParentScalarWhereInput!
  data: ParentUpdateManyDataInput!
}

input ParentUpdateWithoutAthleteDataInput {
  fullName: String
  email: String
  password: String
  phoneNumber: String
  team: TeamUpdateOneRequiredInput
}

input ParentUpdateWithWhereUniqueWithoutAthleteInput {
  where: ParentWhereUniqueInput!
  data: ParentUpdateWithoutAthleteDataInput!
}

input ParentUpsertWithWhereUniqueWithoutAthleteInput {
  where: ParentWhereUniqueInput!
  update: ParentUpdateWithoutAthleteDataInput!
  create: ParentCreateWithoutAthleteInput!
}

input ParentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  team: TeamWhereInput
  athlete: AthleteWhereInput
  AND: [ParentWhereInput!]
  OR: [ParentWhereInput!]
  NOT: [ParentWhereInput!]
}

input ParentWhereUniqueInput {
  id: ID
}

type Post {
  id: ID!
  postedBy: Coach!
  title: String!
  content: String!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  postedBy: CoachCreateOneInput!
  title: String!
  content: String!
  comments: CommentCreateManyWithoutPostInput
}

input PostCreateManyInput {
  create: [PostCreateInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutCommentsInput {
  id: ID
  postedBy: CoachCreateOneInput!
  title: String!
  content: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type PostPreviousValues {
  id: ID!
  title: String!
  content: String!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateDataInput {
  postedBy: CoachUpdateOneRequiredInput
  title: String
  content: String
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateInput {
  postedBy: CoachUpdateOneRequiredInput
  title: String
  content: String
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateManyDataInput {
  title: String
  content: String
}

input PostUpdateManyInput {
  create: [PostCreateInput!]
  update: [PostUpdateWithWhereUniqueNestedInput!]
  upsert: [PostUpsertWithWhereUniqueNestedInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyMutationInput {
  title: String
  content: String
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutCommentsDataInput {
  postedBy: CoachUpdateOneRequiredInput
  title: String
  content: String
}

input PostUpdateWithWhereUniqueNestedInput {
  where: PostWhereUniqueInput!
  data: PostUpdateDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithWhereUniqueNestedInput {
  where: PostWhereUniqueInput!
  update: PostUpdateDataInput!
  create: PostCreateInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  postedBy: CoachWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  athlete(where: AthleteWhereUniqueInput!): Athlete
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete]!
  athletesConnection(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AthleteConnection!
  athleteSchedule(where: AthleteScheduleWhereUniqueInput!): AthleteSchedule
  athleteSchedules(where: AthleteScheduleWhereInput, orderBy: AthleteScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AthleteSchedule]!
  athleteSchedulesConnection(where: AthleteScheduleWhereInput, orderBy: AthleteScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AthleteScheduleConnection!
  athleteStats(where: AthleteStatsWhereUniqueInput!): AthleteStats
  athleteStatses(where: AthleteStatsWhereInput, orderBy: AthleteStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AthleteStats]!
  athleteStatsesConnection(where: AthleteStatsWhereInput, orderBy: AthleteStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AthleteStatsConnection!
  coach(where: CoachWhereUniqueInput!): Coach
  coaches(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach]!
  coachesConnection(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CoachConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  headCoach(where: HeadCoachWhereUniqueInput!): HeadCoach
  headCoaches(where: HeadCoachWhereInput, orderBy: HeadCoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HeadCoach]!
  headCoachesConnection(where: HeadCoachWhereInput, orderBy: HeadCoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HeadCoachConnection!
  logItem(where: LogItemWhereUniqueInput!): LogItem
  logItems(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LogItem]!
  logItemsConnection(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogItemConnection!
  parent(where: ParentWhereUniqueInput!): Parent
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent]!
  parentsConnection(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParentConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  result(where: ResultWhereUniqueInput!): Result
  results(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Result]!
  resultsConnection(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResultConnection!
  subTeam(where: SubTeamWhereUniqueInput!): SubTeam
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam]!
  subTeamsConnection(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubTeamConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  teamSchedule(where: TeamScheduleWhereUniqueInput!): TeamSchedule
  teamSchedules(where: TeamScheduleWhereInput, orderBy: TeamScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TeamSchedule]!
  teamSchedulesConnection(where: TeamScheduleWhereInput, orderBy: TeamScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamScheduleConnection!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout]!
  workoutsConnection(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutConnection!
  node(id: ID!): Node
}

type Result {
  id: ID!
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: Athlete!
}

type ResultConnection {
  pageInfo: PageInfo!
  edges: [ResultEdge]!
  aggregate: AggregateResult!
}

input ResultCreateInput {
  id: ID
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteCreateOneInput!
}

input ResultCreateOneInput {
  create: ResultCreateInput
  connect: ResultWhereUniqueInput
}

type ResultEdge {
  node: Result!
  cursor: String!
}

enum ResultOrderByInput {
  id_ASC
  id_DESC
  rpe_ASC
  rpe_DESC
  compResult_ASC
  compResult_DESC
  sessionResult_ASC
  sessionResult_DESC
}

type ResultPreviousValues {
  id: ID!
  rpe: Int
  compResult: Int
  sessionResult: String
}

type ResultSubscriptionPayload {
  mutation: MutationType!
  node: Result
  updatedFields: [String!]
  previousValues: ResultPreviousValues
}

input ResultSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResultWhereInput
  AND: [ResultSubscriptionWhereInput!]
  OR: [ResultSubscriptionWhereInput!]
  NOT: [ResultSubscriptionWhereInput!]
}

input ResultUpdateDataInput {
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteUpdateOneRequiredInput
}

input ResultUpdateInput {
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteUpdateOneRequiredInput
}

input ResultUpdateManyMutationInput {
  rpe: Int
  compResult: Int
  sessionResult: String
}

input ResultUpdateOneRequiredInput {
  create: ResultCreateInput
  update: ResultUpdateDataInput
  upsert: ResultUpsertNestedInput
  connect: ResultWhereUniqueInput
}

input ResultUpsertNestedInput {
  update: ResultUpdateDataInput!
  create: ResultCreateInput!
}

input ResultWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rpe: Int
  rpe_not: Int
  rpe_in: [Int!]
  rpe_not_in: [Int!]
  rpe_lt: Int
  rpe_lte: Int
  rpe_gt: Int
  rpe_gte: Int
  compResult: Int
  compResult_not: Int
  compResult_in: [Int!]
  compResult_not_in: [Int!]
  compResult_lt: Int
  compResult_lte: Int
  compResult_gt: Int
  compResult_gte: Int
  sessionResult: String
  sessionResult_not: String
  sessionResult_in: [String!]
  sessionResult_not_in: [String!]
  sessionResult_lt: String
  sessionResult_lte: String
  sessionResult_gt: String
  sessionResult_gte: String
  sessionResult_contains: String
  sessionResult_not_contains: String
  sessionResult_starts_with: String
  sessionResult_not_starts_with: String
  sessionResult_ends_with: String
  sessionResult_not_ends_with: String
  athlete: AthleteWhereInput
  AND: [ResultWhereInput!]
  OR: [ResultWhereInput!]
  NOT: [ResultWhereInput!]
}

input ResultWhereUniqueInput {
  id: ID
}

type Subscription {
  athlete(where: AthleteSubscriptionWhereInput): AthleteSubscriptionPayload
  athleteSchedule(where: AthleteScheduleSubscriptionWhereInput): AthleteScheduleSubscriptionPayload
  athleteStats(where: AthleteStatsSubscriptionWhereInput): AthleteStatsSubscriptionPayload
  coach(where: CoachSubscriptionWhereInput): CoachSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  headCoach(where: HeadCoachSubscriptionWhereInput): HeadCoachSubscriptionPayload
  logItem(where: LogItemSubscriptionWhereInput): LogItemSubscriptionPayload
  parent(where: ParentSubscriptionWhereInput): ParentSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  result(where: ResultSubscriptionWhereInput): ResultSubscriptionPayload
  subTeam(where: SubTeamSubscriptionWhereInput): SubTeamSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  teamSchedule(where: TeamScheduleSubscriptionWhereInput): TeamScheduleSubscriptionPayload
  workout(where: WorkoutSubscriptionWhereInput): WorkoutSubscriptionPayload
}

type SubTeam {
  id: ID!
  subTeamName: String!
  subTeamSchedule: TeamSchedule
  parentTeam: Team!
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  coaches(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach!]
  headCoach: HeadCoach!
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
}

type SubTeamConnection {
  pageInfo: PageInfo!
  edges: [SubTeamEdge]!
  aggregate: AggregateSubTeam!
}

input SubTeamCreateInput {
  id: ID
  subTeamName: String!
  subTeamSchedule: TeamScheduleCreateOneInput
  parentTeam: TeamCreateOneWithoutSubTeamsInput!
  athletes: AthleteCreateManyWithoutSubTeamInput
  coaches: CoachCreateManyWithoutSubTeamsInput
  headCoach: HeadCoachCreateOneWithoutSubTeamsInput!
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

input SubTeamCreateManyWithoutCoachesInput {
  create: [SubTeamCreateWithoutCoachesInput!]
  connect: [SubTeamWhereUniqueInput!]
}

input SubTeamCreateManyWithoutHeadCoachInput {
  create: [SubTeamCreateWithoutHeadCoachInput!]
  connect: [SubTeamWhereUniqueInput!]
}

input SubTeamCreateManyWithoutParentTeamInput {
  create: [SubTeamCreateWithoutParentTeamInput!]
  connect: [SubTeamWhereUniqueInput!]
}

input SubTeamCreateOneWithoutAthletesInput {
  create: SubTeamCreateWithoutAthletesInput
  connect: SubTeamWhereUniqueInput
}

input SubTeamCreateWithoutAthletesInput {
  id: ID
  subTeamName: String!
  subTeamSchedule: TeamScheduleCreateOneInput
  parentTeam: TeamCreateOneWithoutSubTeamsInput!
  coaches: CoachCreateManyWithoutSubTeamsInput
  headCoach: HeadCoachCreateOneWithoutSubTeamsInput!
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

input SubTeamCreateWithoutCoachesInput {
  id: ID
  subTeamName: String!
  subTeamSchedule: TeamScheduleCreateOneInput
  parentTeam: TeamCreateOneWithoutSubTeamsInput!
  athletes: AthleteCreateManyWithoutSubTeamInput
  headCoach: HeadCoachCreateOneWithoutSubTeamsInput!
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

input SubTeamCreateWithoutHeadCoachInput {
  id: ID
  subTeamName: String!
  subTeamSchedule: TeamScheduleCreateOneInput
  parentTeam: TeamCreateOneWithoutSubTeamsInput!
  athletes: AthleteCreateManyWithoutSubTeamInput
  coaches: CoachCreateManyWithoutSubTeamsInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

input SubTeamCreateWithoutParentTeamInput {
  id: ID
  subTeamName: String!
  subTeamSchedule: TeamScheduleCreateOneInput
  athletes: AthleteCreateManyWithoutSubTeamInput
  coaches: CoachCreateManyWithoutSubTeamsInput
  headCoach: HeadCoachCreateOneWithoutSubTeamsInput!
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

type SubTeamEdge {
  node: SubTeam!
  cursor: String!
}

enum SubTeamOrderByInput {
  id_ASC
  id_DESC
  subTeamName_ASC
  subTeamName_DESC
}

type SubTeamPreviousValues {
  id: ID!
  subTeamName: String!
}

input SubTeamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subTeamName: String
  subTeamName_not: String
  subTeamName_in: [String!]
  subTeamName_not_in: [String!]
  subTeamName_lt: String
  subTeamName_lte: String
  subTeamName_gt: String
  subTeamName_gte: String
  subTeamName_contains: String
  subTeamName_not_contains: String
  subTeamName_starts_with: String
  subTeamName_not_starts_with: String
  subTeamName_ends_with: String
  subTeamName_not_ends_with: String
  AND: [SubTeamScalarWhereInput!]
  OR: [SubTeamScalarWhereInput!]
  NOT: [SubTeamScalarWhereInput!]
}

type SubTeamSubscriptionPayload {
  mutation: MutationType!
  node: SubTeam
  updatedFields: [String!]
  previousValues: SubTeamPreviousValues
}

input SubTeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubTeamWhereInput
  AND: [SubTeamSubscriptionWhereInput!]
  OR: [SubTeamSubscriptionWhereInput!]
  NOT: [SubTeamSubscriptionWhereInput!]
}

input SubTeamUpdateInput {
  subTeamName: String
  subTeamSchedule: TeamScheduleUpdateOneInput
  parentTeam: TeamUpdateOneRequiredWithoutSubTeamsInput
  athletes: AthleteUpdateManyWithoutSubTeamInput
  coaches: CoachUpdateManyWithoutSubTeamsInput
  headCoach: HeadCoachUpdateOneRequiredWithoutSubTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateManyDataInput {
  subTeamName: String
}

input SubTeamUpdateManyMutationInput {
  subTeamName: String
}

input SubTeamUpdateManyWithoutCoachesInput {
  create: [SubTeamCreateWithoutCoachesInput!]
  delete: [SubTeamWhereUniqueInput!]
  connect: [SubTeamWhereUniqueInput!]
  set: [SubTeamWhereUniqueInput!]
  disconnect: [SubTeamWhereUniqueInput!]
  update: [SubTeamUpdateWithWhereUniqueWithoutCoachesInput!]
  upsert: [SubTeamUpsertWithWhereUniqueWithoutCoachesInput!]
  deleteMany: [SubTeamScalarWhereInput!]
  updateMany: [SubTeamUpdateManyWithWhereNestedInput!]
}

input SubTeamUpdateManyWithoutHeadCoachInput {
  create: [SubTeamCreateWithoutHeadCoachInput!]
  delete: [SubTeamWhereUniqueInput!]
  connect: [SubTeamWhereUniqueInput!]
  set: [SubTeamWhereUniqueInput!]
  disconnect: [SubTeamWhereUniqueInput!]
  update: [SubTeamUpdateWithWhereUniqueWithoutHeadCoachInput!]
  upsert: [SubTeamUpsertWithWhereUniqueWithoutHeadCoachInput!]
  deleteMany: [SubTeamScalarWhereInput!]
  updateMany: [SubTeamUpdateManyWithWhereNestedInput!]
}

input SubTeamUpdateManyWithoutParentTeamInput {
  create: [SubTeamCreateWithoutParentTeamInput!]
  delete: [SubTeamWhereUniqueInput!]
  connect: [SubTeamWhereUniqueInput!]
  set: [SubTeamWhereUniqueInput!]
  disconnect: [SubTeamWhereUniqueInput!]
  update: [SubTeamUpdateWithWhereUniqueWithoutParentTeamInput!]
  upsert: [SubTeamUpsertWithWhereUniqueWithoutParentTeamInput!]
  deleteMany: [SubTeamScalarWhereInput!]
  updateMany: [SubTeamUpdateManyWithWhereNestedInput!]
}

input SubTeamUpdateManyWithWhereNestedInput {
  where: SubTeamScalarWhereInput!
  data: SubTeamUpdateManyDataInput!
}

input SubTeamUpdateOneWithoutAthletesInput {
  create: SubTeamCreateWithoutAthletesInput
  update: SubTeamUpdateWithoutAthletesDataInput
  upsert: SubTeamUpsertWithoutAthletesInput
  delete: Boolean
  disconnect: Boolean
  connect: SubTeamWhereUniqueInput
}

input SubTeamUpdateWithoutAthletesDataInput {
  subTeamName: String
  subTeamSchedule: TeamScheduleUpdateOneInput
  parentTeam: TeamUpdateOneRequiredWithoutSubTeamsInput
  coaches: CoachUpdateManyWithoutSubTeamsInput
  headCoach: HeadCoachUpdateOneRequiredWithoutSubTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateWithoutCoachesDataInput {
  subTeamName: String
  subTeamSchedule: TeamScheduleUpdateOneInput
  parentTeam: TeamUpdateOneRequiredWithoutSubTeamsInput
  athletes: AthleteUpdateManyWithoutSubTeamInput
  headCoach: HeadCoachUpdateOneRequiredWithoutSubTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateWithoutHeadCoachDataInput {
  subTeamName: String
  subTeamSchedule: TeamScheduleUpdateOneInput
  parentTeam: TeamUpdateOneRequiredWithoutSubTeamsInput
  athletes: AthleteUpdateManyWithoutSubTeamInput
  coaches: CoachUpdateManyWithoutSubTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateWithoutParentTeamDataInput {
  subTeamName: String
  subTeamSchedule: TeamScheduleUpdateOneInput
  athletes: AthleteUpdateManyWithoutSubTeamInput
  coaches: CoachUpdateManyWithoutSubTeamsInput
  headCoach: HeadCoachUpdateOneRequiredWithoutSubTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateWithWhereUniqueWithoutCoachesInput {
  where: SubTeamWhereUniqueInput!
  data: SubTeamUpdateWithoutCoachesDataInput!
}

input SubTeamUpdateWithWhereUniqueWithoutHeadCoachInput {
  where: SubTeamWhereUniqueInput!
  data: SubTeamUpdateWithoutHeadCoachDataInput!
}

input SubTeamUpdateWithWhereUniqueWithoutParentTeamInput {
  where: SubTeamWhereUniqueInput!
  data: SubTeamUpdateWithoutParentTeamDataInput!
}

input SubTeamUpsertWithoutAthletesInput {
  update: SubTeamUpdateWithoutAthletesDataInput!
  create: SubTeamCreateWithoutAthletesInput!
}

input SubTeamUpsertWithWhereUniqueWithoutCoachesInput {
  where: SubTeamWhereUniqueInput!
  update: SubTeamUpdateWithoutCoachesDataInput!
  create: SubTeamCreateWithoutCoachesInput!
}

input SubTeamUpsertWithWhereUniqueWithoutHeadCoachInput {
  where: SubTeamWhereUniqueInput!
  update: SubTeamUpdateWithoutHeadCoachDataInput!
  create: SubTeamCreateWithoutHeadCoachInput!
}

input SubTeamUpsertWithWhereUniqueWithoutParentTeamInput {
  where: SubTeamWhereUniqueInput!
  update: SubTeamUpdateWithoutParentTeamDataInput!
  create: SubTeamCreateWithoutParentTeamInput!
}

input SubTeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subTeamName: String
  subTeamName_not: String
  subTeamName_in: [String!]
  subTeamName_not_in: [String!]
  subTeamName_lt: String
  subTeamName_lte: String
  subTeamName_gt: String
  subTeamName_gte: String
  subTeamName_contains: String
  subTeamName_not_contains: String
  subTeamName_starts_with: String
  subTeamName_not_starts_with: String
  subTeamName_ends_with: String
  subTeamName_not_ends_with: String
  subTeamSchedule: TeamScheduleWhereInput
  parentTeam: TeamWhereInput
  athletes_every: AthleteWhereInput
  athletes_some: AthleteWhereInput
  athletes_none: AthleteWhereInput
  coaches_every: CoachWhereInput
  coaches_some: CoachWhereInput
  coaches_none: CoachWhereInput
  headCoach: HeadCoachWhereInput
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  AND: [SubTeamWhereInput!]
  OR: [SubTeamWhereInput!]
  NOT: [SubTeamWhereInput!]
}

input SubTeamWhereUniqueInput {
  id: ID
}

type Team {
  id: ID!
  teamName: String!
  headCoach: HeadCoach
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  coaches(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach!]
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam!]
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  schedule: TeamSchedule
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  coaches: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyWithoutParentTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: TeamScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutAthletesInput {
  create: TeamCreateWithoutAthletesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutCoachesInput {
  create: TeamCreateWithoutCoachesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutHeadCoachInput {
  create: TeamCreateWithoutHeadCoachInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutScheduleInput {
  create: TeamCreateWithoutScheduleInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutSubTeamsInput {
  create: TeamCreateWithoutSubTeamsInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAthletesInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  coaches: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyWithoutParentTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: TeamScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutCoachesInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyWithoutParentTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: TeamScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutHeadCoachInput {
  id: ID
  teamName: String!
  athletes: AthleteCreateManyWithoutTeamInput
  coaches: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyWithoutParentTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: TeamScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutScheduleInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  coaches: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyWithoutParentTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutSubTeamsInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  coaches: CoachCreateManyWithoutTeamInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: TeamScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  teamName_ASC
  teamName_DESC
  phase_ASC
  phase_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  homeGym_ASC
  homeGym_DESC
  teamKey_ASC
  teamKey_DESC
  coachKey_ASC
  coachKey_DESC
}

type TeamPreviousValues {
  id: ID!
  teamName: String!
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamSchedule {
  id: ID!
  createdBy: Coach
  createdAt: DateTime!
  team: Team
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
}

type TeamScheduleConnection {
  pageInfo: PageInfo!
  edges: [TeamScheduleEdge]!
  aggregate: AggregateTeamSchedule!
}

input TeamScheduleCreateInput {
  id: ID
  createdBy: CoachCreateOneInput
  team: TeamCreateOneWithoutScheduleInput
  athletes: AthleteCreateManyInput
  library: WorkoutCreateManyInput
}

input TeamScheduleCreateOneInput {
  create: TeamScheduleCreateInput
  connect: TeamScheduleWhereUniqueInput
}

input TeamScheduleCreateOneWithoutTeamInput {
  create: TeamScheduleCreateWithoutTeamInput
  connect: TeamScheduleWhereUniqueInput
}

input TeamScheduleCreateWithoutTeamInput {
  id: ID
  createdBy: CoachCreateOneInput
  athletes: AthleteCreateManyInput
  library: WorkoutCreateManyInput
}

type TeamScheduleEdge {
  node: TeamSchedule!
  cursor: String!
}

enum TeamScheduleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type TeamSchedulePreviousValues {
  id: ID!
  createdAt: DateTime!
}

type TeamScheduleSubscriptionPayload {
  mutation: MutationType!
  node: TeamSchedule
  updatedFields: [String!]
  previousValues: TeamSchedulePreviousValues
}

input TeamScheduleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamScheduleWhereInput
  AND: [TeamScheduleSubscriptionWhereInput!]
  OR: [TeamScheduleSubscriptionWhereInput!]
  NOT: [TeamScheduleSubscriptionWhereInput!]
}

input TeamScheduleUpdateDataInput {
  createdBy: CoachUpdateOneInput
  team: TeamUpdateOneWithoutScheduleInput
  athletes: AthleteUpdateManyInput
  library: WorkoutUpdateManyInput
}

input TeamScheduleUpdateInput {
  createdBy: CoachUpdateOneInput
  team: TeamUpdateOneWithoutScheduleInput
  athletes: AthleteUpdateManyInput
  library: WorkoutUpdateManyInput
}

input TeamScheduleUpdateOneInput {
  create: TeamScheduleCreateInput
  update: TeamScheduleUpdateDataInput
  upsert: TeamScheduleUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamScheduleWhereUniqueInput
}

input TeamScheduleUpdateOneWithoutTeamInput {
  create: TeamScheduleCreateWithoutTeamInput
  update: TeamScheduleUpdateWithoutTeamDataInput
  upsert: TeamScheduleUpsertWithoutTeamInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamScheduleWhereUniqueInput
}

input TeamScheduleUpdateWithoutTeamDataInput {
  createdBy: CoachUpdateOneInput
  athletes: AthleteUpdateManyInput
  library: WorkoutUpdateManyInput
}

input TeamScheduleUpsertNestedInput {
  update: TeamScheduleUpdateDataInput!
  create: TeamScheduleCreateInput!
}

input TeamScheduleUpsertWithoutTeamInput {
  update: TeamScheduleUpdateWithoutTeamDataInput!
  create: TeamScheduleCreateWithoutTeamInput!
}

input TeamScheduleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdBy: CoachWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  team: TeamWhereInput
  athletes_every: AthleteWhereInput
  athletes_some: AthleteWhereInput
  athletes_none: AthleteWhereInput
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  AND: [TeamScheduleWhereInput!]
  OR: [TeamScheduleWhereInput!]
  NOT: [TeamScheduleWhereInput!]
}

input TeamScheduleWhereUniqueInput {
  id: ID
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateManyMutationInput {
  teamName: String
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateOneRequiredInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutSubTeamsInput {
  create: TeamCreateWithoutSubTeamsInput
  update: TeamUpdateWithoutSubTeamsDataInput
  upsert: TeamUpsertWithoutSubTeamsInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutAthletesInput {
  create: TeamCreateWithoutAthletesInput
  update: TeamUpdateWithoutAthletesDataInput
  upsert: TeamUpsertWithoutAthletesInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutCoachesInput {
  create: TeamCreateWithoutCoachesInput
  update: TeamUpdateWithoutCoachesDataInput
  upsert: TeamUpsertWithoutCoachesInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutHeadCoachInput {
  create: TeamCreateWithoutHeadCoachInput
  update: TeamUpdateWithoutHeadCoachDataInput
  upsert: TeamUpsertWithoutHeadCoachInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutScheduleInput {
  create: TeamCreateWithoutScheduleInput
  update: TeamUpdateWithoutScheduleDataInput
  upsert: TeamUpsertWithoutScheduleInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutAthletesDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutCoachesDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutHeadCoachDataInput {
  teamName: String
  athletes: AthleteUpdateManyWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutScheduleDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyWithoutParentTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutSubTeamsDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coaches: CoachUpdateManyWithoutTeamInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: TeamScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamUpsertWithoutAthletesInput {
  update: TeamUpdateWithoutAthletesDataInput!
  create: TeamCreateWithoutAthletesInput!
}

input TeamUpsertWithoutCoachesInput {
  update: TeamUpdateWithoutCoachesDataInput!
  create: TeamCreateWithoutCoachesInput!
}

input TeamUpsertWithoutHeadCoachInput {
  update: TeamUpdateWithoutHeadCoachDataInput!
  create: TeamCreateWithoutHeadCoachInput!
}

input TeamUpsertWithoutScheduleInput {
  update: TeamUpdateWithoutScheduleDataInput!
  create: TeamCreateWithoutScheduleInput!
}

input TeamUpsertWithoutSubTeamsInput {
  update: TeamUpdateWithoutSubTeamsDataInput!
  create: TeamCreateWithoutSubTeamsInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  teamName: String
  teamName_not: String
  teamName_in: [String!]
  teamName_not_in: [String!]
  teamName_lt: String
  teamName_lte: String
  teamName_gt: String
  teamName_gte: String
  teamName_contains: String
  teamName_not_contains: String
  teamName_starts_with: String
  teamName_not_starts_with: String
  teamName_ends_with: String
  teamName_not_ends_with: String
  headCoach: HeadCoachWhereInput
  athletes_every: AthleteWhereInput
  athletes_some: AthleteWhereInput
  athletes_none: AthleteWhereInput
  coaches_every: CoachWhereInput
  coaches_some: CoachWhereInput
  coaches_none: CoachWhereInput
  subTeams_every: SubTeamWhereInput
  subTeams_some: SubTeamWhereInput
  subTeams_none: SubTeamWhereInput
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  schedule: TeamScheduleWhereInput
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  homeGym: String
  homeGym_not: String
  homeGym_in: [String!]
  homeGym_not_in: [String!]
  homeGym_lt: String
  homeGym_lte: String
  homeGym_gt: String
  homeGym_gte: String
  homeGym_contains: String
  homeGym_not_contains: String
  homeGym_starts_with: String
  homeGym_not_starts_with: String
  homeGym_ends_with: String
  homeGym_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  coachKey: String
  coachKey_not: String
  coachKey_in: [String!]
  coachKey_not_in: [String!]
  coachKey_lt: String
  coachKey_lte: String
  coachKey_gt: String
  coachKey_gte: String
  coachKey_contains: String
  coachKey_not_contains: String
  coachKey_starts_with: String
  coachKey_not_starts_with: String
  coachKey_ends_with: String
  coachKey_not_ends_with: String
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
  teamName: String
}

type Workout {
  id: ID!
  author: String!
  title: String!
  description: String!
}

type WorkoutConnection {
  pageInfo: PageInfo!
  edges: [WorkoutEdge]!
  aggregate: AggregateWorkout!
}

input WorkoutCreateInput {
  id: ID
  author: String!
  title: String!
  description: String!
}

input WorkoutCreateManyInput {
  create: [WorkoutCreateInput!]
  connect: [WorkoutWhereUniqueInput!]
}

type WorkoutEdge {
  node: Workout!
  cursor: String!
}

enum WorkoutOrderByInput {
  id_ASC
  id_DESC
  author_ASC
  author_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
}

type WorkoutPreviousValues {
  id: ID!
  author: String!
  title: String!
  description: String!
}

input WorkoutScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: String
  author_not: String
  author_in: [String!]
  author_not_in: [String!]
  author_lt: String
  author_lte: String
  author_gt: String
  author_gte: String
  author_contains: String
  author_not_contains: String
  author_starts_with: String
  author_not_starts_with: String
  author_ends_with: String
  author_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [WorkoutScalarWhereInput!]
  OR: [WorkoutScalarWhereInput!]
  NOT: [WorkoutScalarWhereInput!]
}

type WorkoutSubscriptionPayload {
  mutation: MutationType!
  node: Workout
  updatedFields: [String!]
  previousValues: WorkoutPreviousValues
}

input WorkoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutWhereInput
  AND: [WorkoutSubscriptionWhereInput!]
  OR: [WorkoutSubscriptionWhereInput!]
  NOT: [WorkoutSubscriptionWhereInput!]
}

input WorkoutUpdateDataInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyDataInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyInput {
  create: [WorkoutCreateInput!]
  update: [WorkoutUpdateWithWhereUniqueNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueNestedInput!]
  delete: [WorkoutWhereUniqueInput!]
  connect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
}

input WorkoutUpdateManyMutationInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyWithWhereNestedInput {
  where: WorkoutScalarWhereInput!
  data: WorkoutUpdateManyDataInput!
}

input WorkoutUpdateWithWhereUniqueNestedInput {
  where: WorkoutWhereUniqueInput!
  data: WorkoutUpdateDataInput!
}

input WorkoutUpsertWithWhereUniqueNestedInput {
  where: WorkoutWhereUniqueInput!
  update: WorkoutUpdateDataInput!
  create: WorkoutCreateInput!
}

input WorkoutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: String
  author_not: String
  author_in: [String!]
  author_not_in: [String!]
  author_lt: String
  author_lte: String
  author_gt: String
  author_gte: String
  author_contains: String
  author_not_contains: String
  author_starts_with: String
  author_not_starts_with: String
  author_ends_with: String
  author_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  NOT: [WorkoutWhereInput!]
}

input WorkoutWhereUniqueInput {
  id: ID
}
`
      }
    