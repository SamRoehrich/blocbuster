module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAthlete {
  count: Int!
}

type AggregateAthleteStats {
  count: Int!
}

type AggregateCoach {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateHeadCoach {
  count: Int!
}

type AggregateLogItem {
  count: Int!
}

type AggregateParent {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateResult {
  count: Int!
}

type AggregateSchedule {
  count: Int!
}

type AggregateSubTeam {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateWorkout {
  count: Int!
}

type Athlete {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  stats(where: AthleteStatsWhereInput, orderBy: AthleteStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AthleteStats!]
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent!]
  team: Team
  teamKey: String!
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  logBook(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LogItem!]
  phase: String
}

type AthleteConnection {
  pageInfo: PageInfo!
  edges: [AthleteEdge]!
  aggregate: AggregateAthlete!
}

input AthleteCreateInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  stats: AthleteStatsCreateManyWithoutUserInput
  parents: ParentCreateManyWithoutAthleteInput
  team: TeamCreateOneWithoutAthletesInput
  teamKey: String!
  library: WorkoutCreateManyInput
  logBook: LogItemCreateManyWithoutUserInput
  phase: String
}

input AthleteCreateManyInput {
  create: [AthleteCreateInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateManyWithoutParentsInput {
  create: [AthleteCreateWithoutParentsInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateManyWithoutTeamInput {
  create: [AthleteCreateWithoutTeamInput!]
  connect: [AthleteWhereUniqueInput!]
}

input AthleteCreateOneInput {
  create: AthleteCreateInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutLogBookInput {
  create: AthleteCreateWithoutLogBookInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateOneWithoutStatsInput {
  create: AthleteCreateWithoutStatsInput
  connect: AthleteWhereUniqueInput
}

input AthleteCreateWithoutLogBookInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  stats: AthleteStatsCreateManyWithoutUserInput
  parents: ParentCreateManyWithoutAthleteInput
  team: TeamCreateOneWithoutAthletesInput
  teamKey: String!
  library: WorkoutCreateManyInput
  phase: String
}

input AthleteCreateWithoutParentsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  stats: AthleteStatsCreateManyWithoutUserInput
  team: TeamCreateOneWithoutAthletesInput
  teamKey: String!
  library: WorkoutCreateManyInput
  logBook: LogItemCreateManyWithoutUserInput
  phase: String
}

input AthleteCreateWithoutStatsInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  parents: ParentCreateManyWithoutAthleteInput
  team: TeamCreateOneWithoutAthletesInput
  teamKey: String!
  library: WorkoutCreateManyInput
  logBook: LogItemCreateManyWithoutUserInput
  phase: String
}

input AthleteCreateWithoutTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  stats: AthleteStatsCreateManyWithoutUserInput
  parents: ParentCreateManyWithoutAthleteInput
  teamKey: String!
  library: WorkoutCreateManyInput
  logBook: LogItemCreateManyWithoutUserInput
  phase: String
}

type AthleteEdge {
  node: Athlete!
  cursor: String!
}

enum AthleteOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  teamKey_ASC
  teamKey_DESC
  phase_ASC
  phase_DESC
}

type AthletePreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  phase: String
}

input AthleteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  AND: [AthleteScalarWhereInput!]
  OR: [AthleteScalarWhereInput!]
  NOT: [AthleteScalarWhereInput!]
}

type AthleteStats {
  id: ID!
  user: Athlete!
  createdAt: DateTime!
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float!
  goalVGrade: Int!
  goalSportGrade: String!
}

type AthleteStatsConnection {
  pageInfo: PageInfo!
  edges: [AthleteStatsEdge]!
  aggregate: AggregateAthleteStats!
}

input AthleteStatsCreateInput {
  id: ID
  user: AthleteCreateOneWithoutStatsInput!
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float!
  goalVGrade: Int!
  goalSportGrade: String!
}

input AthleteStatsCreateManyWithoutUserInput {
  create: [AthleteStatsCreateWithoutUserInput!]
  connect: [AthleteStatsWhereUniqueInput!]
}

input AthleteStatsCreateWithoutUserInput {
  id: ID
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float!
  goalVGrade: Int!
  goalSportGrade: String!
}

type AthleteStatsEdge {
  node: AthleteStats!
  cursor: String!
}

enum AthleteStatsOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  apeIndex_ASC
  apeIndex_DESC
  height_ASC
  height_DESC
  weight_ASC
  weight_DESC
  maxVGrade_ASC
  maxVGrade_DESC
  maxSportGrade_ASC
  maxSportGrade_DESC
  maxEdgeLoad_ASC
  maxEdgeLoad_DESC
  maxEdgeTestSize_ASC
  maxEdgeTestSize_DESC
  SWREdge_ASC
  SWREdge_DESC
  maxPullLoad_ASC
  maxPullLoad_DESC
  SWRBar_ASC
  SWRBar_DESC
  oneArmHangLoadLeft_ASC
  oneArmHangLoadLeft_DESC
  oneArmHangLoadRight_ASC
  oneArmHangLoadRight_DESC
  oneArmHangSWR_ASC
  oneArmHangSWR_DESC
  goalVGrade_ASC
  goalVGrade_DESC
  goalSportGrade_ASC
  goalSportGrade_DESC
}

type AthleteStatsPreviousValues {
  id: ID!
  createdAt: DateTime!
  apeIndex: Int!
  height: Int!
  weight: Int!
  maxVGrade: Int!
  maxSportGrade: String!
  maxEdgeLoad: Int!
  maxEdgeTestSize: Int!
  SWREdge: Float
  maxPullLoad: Int!
  SWRBar: Float
  oneArmHangLoadLeft: Int!
  oneArmHangLoadRight: Int!
  oneArmHangSWR: Float!
  goalVGrade: Int!
  goalSportGrade: String!
}

input AthleteStatsScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  apeIndex: Int
  apeIndex_not: Int
  apeIndex_in: [Int!]
  apeIndex_not_in: [Int!]
  apeIndex_lt: Int
  apeIndex_lte: Int
  apeIndex_gt: Int
  apeIndex_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  maxVGrade: Int
  maxVGrade_not: Int
  maxVGrade_in: [Int!]
  maxVGrade_not_in: [Int!]
  maxVGrade_lt: Int
  maxVGrade_lte: Int
  maxVGrade_gt: Int
  maxVGrade_gte: Int
  maxSportGrade: String
  maxSportGrade_not: String
  maxSportGrade_in: [String!]
  maxSportGrade_not_in: [String!]
  maxSportGrade_lt: String
  maxSportGrade_lte: String
  maxSportGrade_gt: String
  maxSportGrade_gte: String
  maxSportGrade_contains: String
  maxSportGrade_not_contains: String
  maxSportGrade_starts_with: String
  maxSportGrade_not_starts_with: String
  maxSportGrade_ends_with: String
  maxSportGrade_not_ends_with: String
  maxEdgeLoad: Int
  maxEdgeLoad_not: Int
  maxEdgeLoad_in: [Int!]
  maxEdgeLoad_not_in: [Int!]
  maxEdgeLoad_lt: Int
  maxEdgeLoad_lte: Int
  maxEdgeLoad_gt: Int
  maxEdgeLoad_gte: Int
  maxEdgeTestSize: Int
  maxEdgeTestSize_not: Int
  maxEdgeTestSize_in: [Int!]
  maxEdgeTestSize_not_in: [Int!]
  maxEdgeTestSize_lt: Int
  maxEdgeTestSize_lte: Int
  maxEdgeTestSize_gt: Int
  maxEdgeTestSize_gte: Int
  SWREdge: Float
  SWREdge_not: Float
  SWREdge_in: [Float!]
  SWREdge_not_in: [Float!]
  SWREdge_lt: Float
  SWREdge_lte: Float
  SWREdge_gt: Float
  SWREdge_gte: Float
  maxPullLoad: Int
  maxPullLoad_not: Int
  maxPullLoad_in: [Int!]
  maxPullLoad_not_in: [Int!]
  maxPullLoad_lt: Int
  maxPullLoad_lte: Int
  maxPullLoad_gt: Int
  maxPullLoad_gte: Int
  SWRBar: Float
  SWRBar_not: Float
  SWRBar_in: [Float!]
  SWRBar_not_in: [Float!]
  SWRBar_lt: Float
  SWRBar_lte: Float
  SWRBar_gt: Float
  SWRBar_gte: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadLeft_not: Int
  oneArmHangLoadLeft_in: [Int!]
  oneArmHangLoadLeft_not_in: [Int!]
  oneArmHangLoadLeft_lt: Int
  oneArmHangLoadLeft_lte: Int
  oneArmHangLoadLeft_gt: Int
  oneArmHangLoadLeft_gte: Int
  oneArmHangLoadRight: Int
  oneArmHangLoadRight_not: Int
  oneArmHangLoadRight_in: [Int!]
  oneArmHangLoadRight_not_in: [Int!]
  oneArmHangLoadRight_lt: Int
  oneArmHangLoadRight_lte: Int
  oneArmHangLoadRight_gt: Int
  oneArmHangLoadRight_gte: Int
  oneArmHangSWR: Float
  oneArmHangSWR_not: Float
  oneArmHangSWR_in: [Float!]
  oneArmHangSWR_not_in: [Float!]
  oneArmHangSWR_lt: Float
  oneArmHangSWR_lte: Float
  oneArmHangSWR_gt: Float
  oneArmHangSWR_gte: Float
  goalVGrade: Int
  goalVGrade_not: Int
  goalVGrade_in: [Int!]
  goalVGrade_not_in: [Int!]
  goalVGrade_lt: Int
  goalVGrade_lte: Int
  goalVGrade_gt: Int
  goalVGrade_gte: Int
  goalSportGrade: String
  goalSportGrade_not: String
  goalSportGrade_in: [String!]
  goalSportGrade_not_in: [String!]
  goalSportGrade_lt: String
  goalSportGrade_lte: String
  goalSportGrade_gt: String
  goalSportGrade_gte: String
  goalSportGrade_contains: String
  goalSportGrade_not_contains: String
  goalSportGrade_starts_with: String
  goalSportGrade_not_starts_with: String
  goalSportGrade_ends_with: String
  goalSportGrade_not_ends_with: String
  AND: [AthleteStatsScalarWhereInput!]
  OR: [AthleteStatsScalarWhereInput!]
  NOT: [AthleteStatsScalarWhereInput!]
}

type AthleteStatsSubscriptionPayload {
  mutation: MutationType!
  node: AthleteStats
  updatedFields: [String!]
  previousValues: AthleteStatsPreviousValues
}

input AthleteStatsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AthleteStatsWhereInput
  AND: [AthleteStatsSubscriptionWhereInput!]
  OR: [AthleteStatsSubscriptionWhereInput!]
  NOT: [AthleteStatsSubscriptionWhereInput!]
}

input AthleteStatsUpdateInput {
  user: AthleteUpdateOneRequiredWithoutStatsInput
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateManyDataInput {
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateManyMutationInput {
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateManyWithoutUserInput {
  create: [AthleteStatsCreateWithoutUserInput!]
  delete: [AthleteStatsWhereUniqueInput!]
  connect: [AthleteStatsWhereUniqueInput!]
  set: [AthleteStatsWhereUniqueInput!]
  disconnect: [AthleteStatsWhereUniqueInput!]
  update: [AthleteStatsUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [AthleteStatsUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [AthleteStatsScalarWhereInput!]
  updateMany: [AthleteStatsUpdateManyWithWhereNestedInput!]
}

input AthleteStatsUpdateManyWithWhereNestedInput {
  where: AthleteStatsScalarWhereInput!
  data: AthleteStatsUpdateManyDataInput!
}

input AthleteStatsUpdateWithoutUserDataInput {
  apeIndex: Int
  height: Int
  weight: Int
  maxVGrade: Int
  maxSportGrade: String
  maxEdgeLoad: Int
  maxEdgeTestSize: Int
  SWREdge: Float
  maxPullLoad: Int
  SWRBar: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadRight: Int
  oneArmHangSWR: Float
  goalVGrade: Int
  goalSportGrade: String
}

input AthleteStatsUpdateWithWhereUniqueWithoutUserInput {
  where: AthleteStatsWhereUniqueInput!
  data: AthleteStatsUpdateWithoutUserDataInput!
}

input AthleteStatsUpsertWithWhereUniqueWithoutUserInput {
  where: AthleteStatsWhereUniqueInput!
  update: AthleteStatsUpdateWithoutUserDataInput!
  create: AthleteStatsCreateWithoutUserInput!
}

input AthleteStatsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: AthleteWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  apeIndex: Int
  apeIndex_not: Int
  apeIndex_in: [Int!]
  apeIndex_not_in: [Int!]
  apeIndex_lt: Int
  apeIndex_lte: Int
  apeIndex_gt: Int
  apeIndex_gte: Int
  height: Int
  height_not: Int
  height_in: [Int!]
  height_not_in: [Int!]
  height_lt: Int
  height_lte: Int
  height_gt: Int
  height_gte: Int
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  maxVGrade: Int
  maxVGrade_not: Int
  maxVGrade_in: [Int!]
  maxVGrade_not_in: [Int!]
  maxVGrade_lt: Int
  maxVGrade_lte: Int
  maxVGrade_gt: Int
  maxVGrade_gte: Int
  maxSportGrade: String
  maxSportGrade_not: String
  maxSportGrade_in: [String!]
  maxSportGrade_not_in: [String!]
  maxSportGrade_lt: String
  maxSportGrade_lte: String
  maxSportGrade_gt: String
  maxSportGrade_gte: String
  maxSportGrade_contains: String
  maxSportGrade_not_contains: String
  maxSportGrade_starts_with: String
  maxSportGrade_not_starts_with: String
  maxSportGrade_ends_with: String
  maxSportGrade_not_ends_with: String
  maxEdgeLoad: Int
  maxEdgeLoad_not: Int
  maxEdgeLoad_in: [Int!]
  maxEdgeLoad_not_in: [Int!]
  maxEdgeLoad_lt: Int
  maxEdgeLoad_lte: Int
  maxEdgeLoad_gt: Int
  maxEdgeLoad_gte: Int
  maxEdgeTestSize: Int
  maxEdgeTestSize_not: Int
  maxEdgeTestSize_in: [Int!]
  maxEdgeTestSize_not_in: [Int!]
  maxEdgeTestSize_lt: Int
  maxEdgeTestSize_lte: Int
  maxEdgeTestSize_gt: Int
  maxEdgeTestSize_gte: Int
  SWREdge: Float
  SWREdge_not: Float
  SWREdge_in: [Float!]
  SWREdge_not_in: [Float!]
  SWREdge_lt: Float
  SWREdge_lte: Float
  SWREdge_gt: Float
  SWREdge_gte: Float
  maxPullLoad: Int
  maxPullLoad_not: Int
  maxPullLoad_in: [Int!]
  maxPullLoad_not_in: [Int!]
  maxPullLoad_lt: Int
  maxPullLoad_lte: Int
  maxPullLoad_gt: Int
  maxPullLoad_gte: Int
  SWRBar: Float
  SWRBar_not: Float
  SWRBar_in: [Float!]
  SWRBar_not_in: [Float!]
  SWRBar_lt: Float
  SWRBar_lte: Float
  SWRBar_gt: Float
  SWRBar_gte: Float
  oneArmHangLoadLeft: Int
  oneArmHangLoadLeft_not: Int
  oneArmHangLoadLeft_in: [Int!]
  oneArmHangLoadLeft_not_in: [Int!]
  oneArmHangLoadLeft_lt: Int
  oneArmHangLoadLeft_lte: Int
  oneArmHangLoadLeft_gt: Int
  oneArmHangLoadLeft_gte: Int
  oneArmHangLoadRight: Int
  oneArmHangLoadRight_not: Int
  oneArmHangLoadRight_in: [Int!]
  oneArmHangLoadRight_not_in: [Int!]
  oneArmHangLoadRight_lt: Int
  oneArmHangLoadRight_lte: Int
  oneArmHangLoadRight_gt: Int
  oneArmHangLoadRight_gte: Int
  oneArmHangSWR: Float
  oneArmHangSWR_not: Float
  oneArmHangSWR_in: [Float!]
  oneArmHangSWR_not_in: [Float!]
  oneArmHangSWR_lt: Float
  oneArmHangSWR_lte: Float
  oneArmHangSWR_gt: Float
  oneArmHangSWR_gte: Float
  goalVGrade: Int
  goalVGrade_not: Int
  goalVGrade_in: [Int!]
  goalVGrade_not_in: [Int!]
  goalVGrade_lt: Int
  goalVGrade_lte: Int
  goalVGrade_gt: Int
  goalVGrade_gte: Int
  goalSportGrade: String
  goalSportGrade_not: String
  goalSportGrade_in: [String!]
  goalSportGrade_not_in: [String!]
  goalSportGrade_lt: String
  goalSportGrade_lte: String
  goalSportGrade_gt: String
  goalSportGrade_gte: String
  goalSportGrade_contains: String
  goalSportGrade_not_contains: String
  goalSportGrade_starts_with: String
  goalSportGrade_not_starts_with: String
  goalSportGrade_ends_with: String
  goalSportGrade_not_ends_with: String
  AND: [AthleteStatsWhereInput!]
  OR: [AthleteStatsWhereInput!]
  NOT: [AthleteStatsWhereInput!]
}

input AthleteStatsWhereUniqueInput {
  id: ID
}

type AthleteSubscriptionPayload {
  mutation: MutationType!
  node: Athlete
  updatedFields: [String!]
  previousValues: AthletePreviousValues
}

input AthleteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AthleteWhereInput
  AND: [AthleteSubscriptionWhereInput!]
  OR: [AthleteSubscriptionWhereInput!]
  NOT: [AthleteSubscriptionWhereInput!]
}

input AthleteUpdateDataInput {
  fullName: String
  email: String
  password: String
  stats: AthleteStatsUpdateManyWithoutUserInput
  parents: ParentUpdateManyWithoutAthleteInput
  team: TeamUpdateOneWithoutAthletesInput
  teamKey: String
  library: WorkoutUpdateManyInput
  logBook: LogItemUpdateManyWithoutUserInput
  phase: String
}

input AthleteUpdateInput {
  fullName: String
  email: String
  password: String
  stats: AthleteStatsUpdateManyWithoutUserInput
  parents: ParentUpdateManyWithoutAthleteInput
  team: TeamUpdateOneWithoutAthletesInput
  teamKey: String
  library: WorkoutUpdateManyInput
  logBook: LogItemUpdateManyWithoutUserInput
  phase: String
}

input AthleteUpdateManyDataInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  phase: String
}

input AthleteUpdateManyInput {
  create: [AthleteCreateInput!]
  update: [AthleteUpdateWithWhereUniqueNestedInput!]
  upsert: [AthleteUpsertWithWhereUniqueNestedInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  phase: String
}

input AthleteUpdateManyWithoutParentsInput {
  create: [AthleteCreateWithoutParentsInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  update: [AthleteUpdateWithWhereUniqueWithoutParentsInput!]
  upsert: [AthleteUpsertWithWhereUniqueWithoutParentsInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyWithoutTeamInput {
  create: [AthleteCreateWithoutTeamInput!]
  delete: [AthleteWhereUniqueInput!]
  connect: [AthleteWhereUniqueInput!]
  set: [AthleteWhereUniqueInput!]
  disconnect: [AthleteWhereUniqueInput!]
  update: [AthleteUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [AthleteUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [AthleteScalarWhereInput!]
  updateMany: [AthleteUpdateManyWithWhereNestedInput!]
}

input AthleteUpdateManyWithWhereNestedInput {
  where: AthleteScalarWhereInput!
  data: AthleteUpdateManyDataInput!
}

input AthleteUpdateOneInput {
  create: AthleteCreateInput
  update: AthleteUpdateDataInput
  upsert: AthleteUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredInput {
  create: AthleteCreateInput
  update: AthleteUpdateDataInput
  upsert: AthleteUpsertNestedInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredWithoutLogBookInput {
  create: AthleteCreateWithoutLogBookInput
  update: AthleteUpdateWithoutLogBookDataInput
  upsert: AthleteUpsertWithoutLogBookInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateOneRequiredWithoutStatsInput {
  create: AthleteCreateWithoutStatsInput
  update: AthleteUpdateWithoutStatsDataInput
  upsert: AthleteUpsertWithoutStatsInput
  connect: AthleteWhereUniqueInput
}

input AthleteUpdateWithoutLogBookDataInput {
  fullName: String
  email: String
  password: String
  stats: AthleteStatsUpdateManyWithoutUserInput
  parents: ParentUpdateManyWithoutAthleteInput
  team: TeamUpdateOneWithoutAthletesInput
  teamKey: String
  library: WorkoutUpdateManyInput
  phase: String
}

input AthleteUpdateWithoutParentsDataInput {
  fullName: String
  email: String
  password: String
  stats: AthleteStatsUpdateManyWithoutUserInput
  team: TeamUpdateOneWithoutAthletesInput
  teamKey: String
  library: WorkoutUpdateManyInput
  logBook: LogItemUpdateManyWithoutUserInput
  phase: String
}

input AthleteUpdateWithoutStatsDataInput {
  fullName: String
  email: String
  password: String
  parents: ParentUpdateManyWithoutAthleteInput
  team: TeamUpdateOneWithoutAthletesInput
  teamKey: String
  library: WorkoutUpdateManyInput
  logBook: LogItemUpdateManyWithoutUserInput
  phase: String
}

input AthleteUpdateWithoutTeamDataInput {
  fullName: String
  email: String
  password: String
  stats: AthleteStatsUpdateManyWithoutUserInput
  parents: ParentUpdateManyWithoutAthleteInput
  teamKey: String
  library: WorkoutUpdateManyInput
  logBook: LogItemUpdateManyWithoutUserInput
  phase: String
}

input AthleteUpdateWithWhereUniqueNestedInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateDataInput!
}

input AthleteUpdateWithWhereUniqueWithoutParentsInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateWithoutParentsDataInput!
}

input AthleteUpdateWithWhereUniqueWithoutTeamInput {
  where: AthleteWhereUniqueInput!
  data: AthleteUpdateWithoutTeamDataInput!
}

input AthleteUpsertNestedInput {
  update: AthleteUpdateDataInput!
  create: AthleteCreateInput!
}

input AthleteUpsertWithoutLogBookInput {
  update: AthleteUpdateWithoutLogBookDataInput!
  create: AthleteCreateWithoutLogBookInput!
}

input AthleteUpsertWithoutStatsInput {
  update: AthleteUpdateWithoutStatsDataInput!
  create: AthleteCreateWithoutStatsInput!
}

input AthleteUpsertWithWhereUniqueNestedInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateDataInput!
  create: AthleteCreateInput!
}

input AthleteUpsertWithWhereUniqueWithoutParentsInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateWithoutParentsDataInput!
  create: AthleteCreateWithoutParentsInput!
}

input AthleteUpsertWithWhereUniqueWithoutTeamInput {
  where: AthleteWhereUniqueInput!
  update: AthleteUpdateWithoutTeamDataInput!
  create: AthleteCreateWithoutTeamInput!
}

input AthleteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  stats_every: AthleteStatsWhereInput
  stats_some: AthleteStatsWhereInput
  stats_none: AthleteStatsWhereInput
  parents_every: ParentWhereInput
  parents_some: ParentWhereInput
  parents_none: ParentWhereInput
  team: TeamWhereInput
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  logBook_every: LogItemWhereInput
  logBook_some: LogItemWhereInput
  logBook_none: LogItemWhereInput
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  AND: [AthleteWhereInput!]
  OR: [AthleteWhereInput!]
  NOT: [AthleteWhereInput!]
}

input AthleteWhereUniqueInput {
  id: ID
  email: String
}

type BatchPayload {
  count: Long!
}

type Coach {
  id: ID!
  fullName: String!
  team: Team
  teams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam!]
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

type CoachConnection {
  pageInfo: PageInfo!
  edges: [CoachEdge]!
  aggregate: AggregateCoach!
}

input CoachCreateInput {
  id: ID
  fullName: String!
  team: TeamCreateOneWithoutCoahcesInput
  teams: SubTeamCreateManyWithoutCoahcesInput
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

input CoachCreateManyWithoutTeamInput {
  create: [CoachCreateWithoutTeamInput!]
  connect: [CoachWhereUniqueInput!]
}

input CoachCreateManyWithoutTeamsInput {
  create: [CoachCreateWithoutTeamsInput!]
  connect: [CoachWhereUniqueInput!]
}

input CoachCreateOneInput {
  create: CoachCreateInput
  connect: CoachWhereUniqueInput
}

input CoachCreateWithoutTeamInput {
  id: ID
  fullName: String!
  teams: SubTeamCreateManyWithoutCoahcesInput
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

input CoachCreateWithoutTeamsInput {
  id: ID
  fullName: String!
  team: TeamCreateOneWithoutCoahcesInput
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

type CoachEdge {
  node: Coach!
  cursor: String!
}

enum CoachOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  teamKey_ASC
  teamKey_DESC
  coachKey_ASC
  coachKey_DESC
}

type CoachPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

input CoachScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  coachKey: String
  coachKey_not: String
  coachKey_in: [String!]
  coachKey_not_in: [String!]
  coachKey_lt: String
  coachKey_lte: String
  coachKey_gt: String
  coachKey_gte: String
  coachKey_contains: String
  coachKey_not_contains: String
  coachKey_starts_with: String
  coachKey_not_starts_with: String
  coachKey_ends_with: String
  coachKey_not_ends_with: String
  AND: [CoachScalarWhereInput!]
  OR: [CoachScalarWhereInput!]
  NOT: [CoachScalarWhereInput!]
}

type CoachSubscriptionPayload {
  mutation: MutationType!
  node: Coach
  updatedFields: [String!]
  previousValues: CoachPreviousValues
}

input CoachSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CoachWhereInput
  AND: [CoachSubscriptionWhereInput!]
  OR: [CoachSubscriptionWhereInput!]
  NOT: [CoachSubscriptionWhereInput!]
}

input CoachUpdateDataInput {
  fullName: String
  team: TeamUpdateOneWithoutCoahcesInput
  teams: SubTeamUpdateManyWithoutCoahcesInput
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateInput {
  fullName: String
  team: TeamUpdateOneWithoutCoahcesInput
  teams: SubTeamUpdateManyWithoutCoahcesInput
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateManyDataInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateManyWithoutTeamInput {
  create: [CoachCreateWithoutTeamInput!]
  delete: [CoachWhereUniqueInput!]
  connect: [CoachWhereUniqueInput!]
  set: [CoachWhereUniqueInput!]
  disconnect: [CoachWhereUniqueInput!]
  update: [CoachUpdateWithWhereUniqueWithoutTeamInput!]
  upsert: [CoachUpsertWithWhereUniqueWithoutTeamInput!]
  deleteMany: [CoachScalarWhereInput!]
  updateMany: [CoachUpdateManyWithWhereNestedInput!]
}

input CoachUpdateManyWithoutTeamsInput {
  create: [CoachCreateWithoutTeamsInput!]
  delete: [CoachWhereUniqueInput!]
  connect: [CoachWhereUniqueInput!]
  set: [CoachWhereUniqueInput!]
  disconnect: [CoachWhereUniqueInput!]
  update: [CoachUpdateWithWhereUniqueWithoutTeamsInput!]
  upsert: [CoachUpsertWithWhereUniqueWithoutTeamsInput!]
  deleteMany: [CoachScalarWhereInput!]
  updateMany: [CoachUpdateManyWithWhereNestedInput!]
}

input CoachUpdateManyWithWhereNestedInput {
  where: CoachScalarWhereInput!
  data: CoachUpdateManyDataInput!
}

input CoachUpdateOneInput {
  create: CoachCreateInput
  update: CoachUpdateDataInput
  upsert: CoachUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CoachWhereUniqueInput
}

input CoachUpdateOneRequiredInput {
  create: CoachCreateInput
  update: CoachUpdateDataInput
  upsert: CoachUpsertNestedInput
  connect: CoachWhereUniqueInput
}

input CoachUpdateWithoutTeamDataInput {
  fullName: String
  teams: SubTeamUpdateManyWithoutCoahcesInput
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateWithoutTeamsDataInput {
  fullName: String
  team: TeamUpdateOneWithoutCoahcesInput
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input CoachUpdateWithWhereUniqueWithoutTeamInput {
  where: CoachWhereUniqueInput!
  data: CoachUpdateWithoutTeamDataInput!
}

input CoachUpdateWithWhereUniqueWithoutTeamsInput {
  where: CoachWhereUniqueInput!
  data: CoachUpdateWithoutTeamsDataInput!
}

input CoachUpsertNestedInput {
  update: CoachUpdateDataInput!
  create: CoachCreateInput!
}

input CoachUpsertWithWhereUniqueWithoutTeamInput {
  where: CoachWhereUniqueInput!
  update: CoachUpdateWithoutTeamDataInput!
  create: CoachCreateWithoutTeamInput!
}

input CoachUpsertWithWhereUniqueWithoutTeamsInput {
  where: CoachWhereUniqueInput!
  update: CoachUpdateWithoutTeamsDataInput!
  create: CoachCreateWithoutTeamsInput!
}

input CoachWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  team: TeamWhereInput
  teams_every: SubTeamWhereInput
  teams_some: SubTeamWhereInput
  teams_none: SubTeamWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  coachKey: String
  coachKey_not: String
  coachKey_in: [String!]
  coachKey_not_in: [String!]
  coachKey_lt: String
  coachKey_lte: String
  coachKey_gt: String
  coachKey_gte: String
  coachKey_contains: String
  coachKey_not_contains: String
  coachKey_starts_with: String
  coachKey_not_starts_with: String
  coachKey_ends_with: String
  coachKey_not_ends_with: String
  AND: [CoachWhereInput!]
  OR: [CoachWhereInput!]
  NOT: [CoachWhereInput!]
}

input CoachWhereUniqueInput {
  id: ID
  email: String
}

type Comment {
  id: ID!
  post: Post!
  coach: Coach
  athlete: Athlete
  content: String!
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  post: PostCreateOneWithoutCommentsInput!
  coach: CoachCreateOneInput
  athlete: AthleteCreateOneInput
  content: String!
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutPostInput {
  id: ID
  coach: CoachCreateOneInput
  athlete: AthleteCreateOneInput
  content: String!
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type CommentPreviousValues {
  id: ID!
  content: String!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  post: PostUpdateOneRequiredWithoutCommentsInput
  coach: CoachUpdateOneInput
  athlete: AthleteUpdateOneInput
  content: String
}

input CommentUpdateManyDataInput {
  content: String
}

input CommentUpdateManyMutationInput {
  content: String
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutPostDataInput {
  coach: CoachUpdateOneInput
  athlete: AthleteUpdateOneInput
  content: String
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  post: PostWhereInput
  coach: CoachWhereInput
  athlete: AthleteWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type HeadCoach {
  id: ID!
  team: Team
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

type HeadCoachConnection {
  pageInfo: PageInfo!
  edges: [HeadCoachEdge]!
  aggregate: AggregateHeadCoach!
}

input HeadCoachCreateInput {
  id: ID
  team: TeamCreateOneWithoutHeadCoachInput
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

input HeadCoachCreateOneInput {
  create: HeadCoachCreateInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachCreateOneWithoutTeamInput {
  create: HeadCoachCreateWithoutTeamInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachCreateWithoutTeamInput {
  id: ID
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

type HeadCoachEdge {
  node: HeadCoach!
  cursor: String!
}

enum HeadCoachOrderByInput {
  id_ASC
  id_DESC
  fullName_ASC
  fullName_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  teamKey_ASC
  teamKey_DESC
  coachKey_ASC
  coachKey_DESC
}

type HeadCoachPreviousValues {
  id: ID!
  fullName: String!
  email: String!
  password: String!
  teamKey: String!
  coachKey: String!
}

type HeadCoachSubscriptionPayload {
  mutation: MutationType!
  node: HeadCoach
  updatedFields: [String!]
  previousValues: HeadCoachPreviousValues
}

input HeadCoachSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HeadCoachWhereInput
  AND: [HeadCoachSubscriptionWhereInput!]
  OR: [HeadCoachSubscriptionWhereInput!]
  NOT: [HeadCoachSubscriptionWhereInput!]
}

input HeadCoachUpdateDataInput {
  team: TeamUpdateOneWithoutHeadCoachInput
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input HeadCoachUpdateInput {
  team: TeamUpdateOneWithoutHeadCoachInput
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input HeadCoachUpdateManyMutationInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input HeadCoachUpdateOneRequiredInput {
  create: HeadCoachCreateInput
  update: HeadCoachUpdateDataInput
  upsert: HeadCoachUpsertNestedInput
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachUpdateOneWithoutTeamInput {
  create: HeadCoachCreateWithoutTeamInput
  update: HeadCoachUpdateWithoutTeamDataInput
  upsert: HeadCoachUpsertWithoutTeamInput
  delete: Boolean
  disconnect: Boolean
  connect: HeadCoachWhereUniqueInput
}

input HeadCoachUpdateWithoutTeamDataInput {
  fullName: String
  email: String
  password: String
  teamKey: String
  coachKey: String
}

input HeadCoachUpsertNestedInput {
  update: HeadCoachUpdateDataInput!
  create: HeadCoachCreateInput!
}

input HeadCoachUpsertWithoutTeamInput {
  update: HeadCoachUpdateWithoutTeamDataInput!
  create: HeadCoachCreateWithoutTeamInput!
}

input HeadCoachWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  team: TeamWhereInput
  fullName: String
  fullName_not: String
  fullName_in: [String!]
  fullName_not_in: [String!]
  fullName_lt: String
  fullName_lte: String
  fullName_gt: String
  fullName_gte: String
  fullName_contains: String
  fullName_not_contains: String
  fullName_starts_with: String
  fullName_not_starts_with: String
  fullName_ends_with: String
  fullName_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  coachKey: String
  coachKey_not: String
  coachKey_in: [String!]
  coachKey_not_in: [String!]
  coachKey_lt: String
  coachKey_lte: String
  coachKey_gt: String
  coachKey_gte: String
  coachKey_contains: String
  coachKey_not_contains: String
  coachKey_starts_with: String
  coachKey_not_starts_with: String
  coachKey_ends_with: String
  coachKey_not_ends_with: String
  AND: [HeadCoachWhereInput!]
  OR: [HeadCoachWhereInput!]
  NOT: [HeadCoachWhereInput!]
}

input HeadCoachWhereUniqueInput {
  id: ID
}

type LogItem {
  user: Athlete!
  id: ID!
  createdAt: DateTime!
  title: String!
  description: String!
  results: Result!
  comment: String
}

type LogItemConnection {
  pageInfo: PageInfo!
  edges: [LogItemEdge]!
  aggregate: AggregateLogItem!
}

input LogItemCreateInput {
  user: AthleteCreateOneWithoutLogBookInput!
  id: ID
  title: String!
  description: String!
  results: ResultCreateOneInput!
  comment: String
}

input LogItemCreateManyWithoutUserInput {
  create: [LogItemCreateWithoutUserInput!]
  connect: [LogItemWhereUniqueInput!]
}

input LogItemCreateWithoutUserInput {
  id: ID
  title: String!
  description: String!
  results: ResultCreateOneInput!
  comment: String
}

type LogItemEdge {
  node: LogItem!
  cursor: String!
}

enum LogItemOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  comment_ASC
  comment_DESC
}

type LogItemPreviousValues {
  id: ID!
  createdAt: DateTime!
  title: String!
  description: String!
  comment: String
}

input LogItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [LogItemScalarWhereInput!]
  OR: [LogItemScalarWhereInput!]
  NOT: [LogItemScalarWhereInput!]
}

type LogItemSubscriptionPayload {
  mutation: MutationType!
  node: LogItem
  updatedFields: [String!]
  previousValues: LogItemPreviousValues
}

input LogItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LogItemWhereInput
  AND: [LogItemSubscriptionWhereInput!]
  OR: [LogItemSubscriptionWhereInput!]
  NOT: [LogItemSubscriptionWhereInput!]
}

input LogItemUpdateInput {
  user: AthleteUpdateOneRequiredWithoutLogBookInput
  title: String
  description: String
  results: ResultUpdateOneRequiredInput
  comment: String
}

input LogItemUpdateManyDataInput {
  title: String
  description: String
  comment: String
}

input LogItemUpdateManyMutationInput {
  title: String
  description: String
  comment: String
}

input LogItemUpdateManyWithoutUserInput {
  create: [LogItemCreateWithoutUserInput!]
  delete: [LogItemWhereUniqueInput!]
  connect: [LogItemWhereUniqueInput!]
  set: [LogItemWhereUniqueInput!]
  disconnect: [LogItemWhereUniqueInput!]
  update: [LogItemUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [LogItemUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [LogItemScalarWhereInput!]
  updateMany: [LogItemUpdateManyWithWhereNestedInput!]
}

input LogItemUpdateManyWithWhereNestedInput {
  where: LogItemScalarWhereInput!
  data: LogItemUpdateManyDataInput!
}

input LogItemUpdateWithoutUserDataInput {
  title: String
  description: String
  results: ResultUpdateOneRequiredInput
  comment: String
}

input LogItemUpdateWithWhereUniqueWithoutUserInput {
  where: LogItemWhereUniqueInput!
  data: LogItemUpdateWithoutUserDataInput!
}

input LogItemUpsertWithWhereUniqueWithoutUserInput {
  where: LogItemWhereUniqueInput!
  update: LogItemUpdateWithoutUserDataInput!
  create: LogItemCreateWithoutUserInput!
}

input LogItemWhereInput {
  user: AthleteWhereInput
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  results: ResultWhereInput
  comment: String
  comment_not: String
  comment_in: [String!]
  comment_not_in: [String!]
  comment_lt: String
  comment_lte: String
  comment_gt: String
  comment_gte: String
  comment_contains: String
  comment_not_contains: String
  comment_starts_with: String
  comment_not_starts_with: String
  comment_ends_with: String
  comment_not_ends_with: String
  AND: [LogItemWhereInput!]
  OR: [LogItemWhereInput!]
  NOT: [LogItemWhereInput!]
}

input LogItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAthlete(data: AthleteCreateInput!): Athlete!
  updateAthlete(data: AthleteUpdateInput!, where: AthleteWhereUniqueInput!): Athlete
  updateManyAthletes(data: AthleteUpdateManyMutationInput!, where: AthleteWhereInput): BatchPayload!
  upsertAthlete(where: AthleteWhereUniqueInput!, create: AthleteCreateInput!, update: AthleteUpdateInput!): Athlete!
  deleteAthlete(where: AthleteWhereUniqueInput!): Athlete
  deleteManyAthletes(where: AthleteWhereInput): BatchPayload!
  createAthleteStats(data: AthleteStatsCreateInput!): AthleteStats!
  updateAthleteStats(data: AthleteStatsUpdateInput!, where: AthleteStatsWhereUniqueInput!): AthleteStats
  updateManyAthleteStatses(data: AthleteStatsUpdateManyMutationInput!, where: AthleteStatsWhereInput): BatchPayload!
  upsertAthleteStats(where: AthleteStatsWhereUniqueInput!, create: AthleteStatsCreateInput!, update: AthleteStatsUpdateInput!): AthleteStats!
  deleteAthleteStats(where: AthleteStatsWhereUniqueInput!): AthleteStats
  deleteManyAthleteStatses(where: AthleteStatsWhereInput): BatchPayload!
  createCoach(data: CoachCreateInput!): Coach!
  updateCoach(data: CoachUpdateInput!, where: CoachWhereUniqueInput!): Coach
  updateManyCoaches(data: CoachUpdateManyMutationInput!, where: CoachWhereInput): BatchPayload!
  upsertCoach(where: CoachWhereUniqueInput!, create: CoachCreateInput!, update: CoachUpdateInput!): Coach!
  deleteCoach(where: CoachWhereUniqueInput!): Coach
  deleteManyCoaches(where: CoachWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createHeadCoach(data: HeadCoachCreateInput!): HeadCoach!
  updateHeadCoach(data: HeadCoachUpdateInput!, where: HeadCoachWhereUniqueInput!): HeadCoach
  updateManyHeadCoaches(data: HeadCoachUpdateManyMutationInput!, where: HeadCoachWhereInput): BatchPayload!
  upsertHeadCoach(where: HeadCoachWhereUniqueInput!, create: HeadCoachCreateInput!, update: HeadCoachUpdateInput!): HeadCoach!
  deleteHeadCoach(where: HeadCoachWhereUniqueInput!): HeadCoach
  deleteManyHeadCoaches(where: HeadCoachWhereInput): BatchPayload!
  createLogItem(data: LogItemCreateInput!): LogItem!
  updateLogItem(data: LogItemUpdateInput!, where: LogItemWhereUniqueInput!): LogItem
  updateManyLogItems(data: LogItemUpdateManyMutationInput!, where: LogItemWhereInput): BatchPayload!
  upsertLogItem(where: LogItemWhereUniqueInput!, create: LogItemCreateInput!, update: LogItemUpdateInput!): LogItem!
  deleteLogItem(where: LogItemWhereUniqueInput!): LogItem
  deleteManyLogItems(where: LogItemWhereInput): BatchPayload!
  createParent(data: ParentCreateInput!): Parent!
  updateParent(data: ParentUpdateInput!, where: ParentWhereUniqueInput!): Parent
  updateManyParents(data: ParentUpdateManyMutationInput!, where: ParentWhereInput): BatchPayload!
  upsertParent(where: ParentWhereUniqueInput!, create: ParentCreateInput!, update: ParentUpdateInput!): Parent!
  deleteParent(where: ParentWhereUniqueInput!): Parent
  deleteManyParents(where: ParentWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createResult(data: ResultCreateInput!): Result!
  updateResult(data: ResultUpdateInput!, where: ResultWhereUniqueInput!): Result
  updateManyResults(data: ResultUpdateManyMutationInput!, where: ResultWhereInput): BatchPayload!
  upsertResult(where: ResultWhereUniqueInput!, create: ResultCreateInput!, update: ResultUpdateInput!): Result!
  deleteResult(where: ResultWhereUniqueInput!): Result
  deleteManyResults(where: ResultWhereInput): BatchPayload!
  createSchedule(data: ScheduleCreateInput!): Schedule!
  updateSchedule(data: ScheduleUpdateInput!, where: ScheduleWhereUniqueInput!): Schedule
  upsertSchedule(where: ScheduleWhereUniqueInput!, create: ScheduleCreateInput!, update: ScheduleUpdateInput!): Schedule!
  deleteSchedule(where: ScheduleWhereUniqueInput!): Schedule
  deleteManySchedules(where: ScheduleWhereInput): BatchPayload!
  createSubTeam(data: SubTeamCreateInput!): SubTeam!
  updateSubTeam(data: SubTeamUpdateInput!, where: SubTeamWhereUniqueInput!): SubTeam
  upsertSubTeam(where: SubTeamWhereUniqueInput!, create: SubTeamCreateInput!, update: SubTeamUpdateInput!): SubTeam!
  deleteSubTeam(where: SubTeamWhereUniqueInput!): SubTeam
  deleteManySubTeams(where: SubTeamWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createWorkout(data: WorkoutCreateInput!): Workout!
  updateWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateManyWorkouts(data: WorkoutUpdateManyMutationInput!, where: WorkoutWhereInput): BatchPayload!
  upsertWorkout(where: WorkoutWhereUniqueInput!, create: WorkoutCreateInput!, update: WorkoutUpdateInput!): Workout!
  deleteWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteManyWorkouts(where: WorkoutWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Parent {
  id: ID!
  athlete(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  email: String!
  password: String!
  phoneNumber: String!
}

type ParentConnection {
  pageInfo: PageInfo!
  edges: [ParentEdge]!
  aggregate: AggregateParent!
}

input ParentCreateInput {
  id: ID
  athlete: AthleteCreateManyWithoutParentsInput
  email: String!
  password: String!
  phoneNumber: String!
}

input ParentCreateManyWithoutAthleteInput {
  create: [ParentCreateWithoutAthleteInput!]
  connect: [ParentWhereUniqueInput!]
}

input ParentCreateWithoutAthleteInput {
  id: ID
  email: String!
  password: String!
  phoneNumber: String!
}

type ParentEdge {
  node: Parent!
  cursor: String!
}

enum ParentOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phoneNumber_ASC
  phoneNumber_DESC
}

type ParentPreviousValues {
  id: ID!
  email: String!
  password: String!
  phoneNumber: String!
}

input ParentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  AND: [ParentScalarWhereInput!]
  OR: [ParentScalarWhereInput!]
  NOT: [ParentScalarWhereInput!]
}

type ParentSubscriptionPayload {
  mutation: MutationType!
  node: Parent
  updatedFields: [String!]
  previousValues: ParentPreviousValues
}

input ParentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ParentWhereInput
  AND: [ParentSubscriptionWhereInput!]
  OR: [ParentSubscriptionWhereInput!]
  NOT: [ParentSubscriptionWhereInput!]
}

input ParentUpdateInput {
  athlete: AthleteUpdateManyWithoutParentsInput
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateManyDataInput {
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateManyMutationInput {
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateManyWithoutAthleteInput {
  create: [ParentCreateWithoutAthleteInput!]
  delete: [ParentWhereUniqueInput!]
  connect: [ParentWhereUniqueInput!]
  set: [ParentWhereUniqueInput!]
  disconnect: [ParentWhereUniqueInput!]
  update: [ParentUpdateWithWhereUniqueWithoutAthleteInput!]
  upsert: [ParentUpsertWithWhereUniqueWithoutAthleteInput!]
  deleteMany: [ParentScalarWhereInput!]
  updateMany: [ParentUpdateManyWithWhereNestedInput!]
}

input ParentUpdateManyWithWhereNestedInput {
  where: ParentScalarWhereInput!
  data: ParentUpdateManyDataInput!
}

input ParentUpdateWithoutAthleteDataInput {
  email: String
  password: String
  phoneNumber: String
}

input ParentUpdateWithWhereUniqueWithoutAthleteInput {
  where: ParentWhereUniqueInput!
  data: ParentUpdateWithoutAthleteDataInput!
}

input ParentUpsertWithWhereUniqueWithoutAthleteInput {
  where: ParentWhereUniqueInput!
  update: ParentUpdateWithoutAthleteDataInput!
  create: ParentCreateWithoutAthleteInput!
}

input ParentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  athlete_every: AthleteWhereInput
  athlete_some: AthleteWhereInput
  athlete_none: AthleteWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  AND: [ParentWhereInput!]
  OR: [ParentWhereInput!]
  NOT: [ParentWhereInput!]
}

input ParentWhereUniqueInput {
  id: ID
}

type Post {
  id: ID!
  coach: Coach!
  title: String!
  content: String!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  coach: CoachCreateOneInput!
  title: String!
  content: String!
  comments: CommentCreateManyWithoutPostInput
}

input PostCreateManyInput {
  create: [PostCreateInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutCommentsInput {
  id: ID
  coach: CoachCreateOneInput!
  title: String!
  content: String!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type PostPreviousValues {
  id: ID!
  title: String!
  content: String!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateDataInput {
  coach: CoachUpdateOneRequiredInput
  title: String
  content: String
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateInput {
  coach: CoachUpdateOneRequiredInput
  title: String
  content: String
  comments: CommentUpdateManyWithoutPostInput
}

input PostUpdateManyDataInput {
  title: String
  content: String
}

input PostUpdateManyInput {
  create: [PostCreateInput!]
  update: [PostUpdateWithWhereUniqueNestedInput!]
  upsert: [PostUpsertWithWhereUniqueNestedInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyMutationInput {
  title: String
  content: String
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneRequiredWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutCommentsDataInput {
  coach: CoachUpdateOneRequiredInput
  title: String
  content: String
}

input PostUpdateWithWhereUniqueNestedInput {
  where: PostWhereUniqueInput!
  data: PostUpdateDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithWhereUniqueNestedInput {
  where: PostWhereUniqueInput!
  update: PostUpdateDataInput!
  create: PostCreateInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  coach: CoachWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Query {
  athlete(where: AthleteWhereUniqueInput!): Athlete
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete]!
  athletesConnection(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AthleteConnection!
  athleteStats(where: AthleteStatsWhereUniqueInput!): AthleteStats
  athleteStatses(where: AthleteStatsWhereInput, orderBy: AthleteStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AthleteStats]!
  athleteStatsesConnection(where: AthleteStatsWhereInput, orderBy: AthleteStatsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AthleteStatsConnection!
  coach(where: CoachWhereUniqueInput!): Coach
  coaches(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach]!
  coachesConnection(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CoachConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  headCoach(where: HeadCoachWhereUniqueInput!): HeadCoach
  headCoaches(where: HeadCoachWhereInput, orderBy: HeadCoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HeadCoach]!
  headCoachesConnection(where: HeadCoachWhereInput, orderBy: HeadCoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HeadCoachConnection!
  logItem(where: LogItemWhereUniqueInput!): LogItem
  logItems(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LogItem]!
  logItemsConnection(where: LogItemWhereInput, orderBy: LogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LogItemConnection!
  parent(where: ParentWhereUniqueInput!): Parent
  parents(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Parent]!
  parentsConnection(where: ParentWhereInput, orderBy: ParentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ParentConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  result(where: ResultWhereUniqueInput!): Result
  results(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Result]!
  resultsConnection(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResultConnection!
  schedule(where: ScheduleWhereUniqueInput!): Schedule
  schedules(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Schedule]!
  schedulesConnection(where: ScheduleWhereInput, orderBy: ScheduleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScheduleConnection!
  subTeam(where: SubTeamWhereUniqueInput!): SubTeam
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam]!
  subTeamsConnection(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubTeamConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout]!
  workoutsConnection(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutConnection!
  node(id: ID!): Node
}

type Result {
  id: ID!
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: Athlete!
}

type ResultConnection {
  pageInfo: PageInfo!
  edges: [ResultEdge]!
  aggregate: AggregateResult!
}

input ResultCreateInput {
  id: ID
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteCreateOneInput!
}

input ResultCreateOneInput {
  create: ResultCreateInput
  connect: ResultWhereUniqueInput
}

type ResultEdge {
  node: Result!
  cursor: String!
}

enum ResultOrderByInput {
  id_ASC
  id_DESC
  rpe_ASC
  rpe_DESC
  compResult_ASC
  compResult_DESC
  sessionResult_ASC
  sessionResult_DESC
}

type ResultPreviousValues {
  id: ID!
  rpe: Int
  compResult: Int
  sessionResult: String
}

type ResultSubscriptionPayload {
  mutation: MutationType!
  node: Result
  updatedFields: [String!]
  previousValues: ResultPreviousValues
}

input ResultSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResultWhereInput
  AND: [ResultSubscriptionWhereInput!]
  OR: [ResultSubscriptionWhereInput!]
  NOT: [ResultSubscriptionWhereInput!]
}

input ResultUpdateDataInput {
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteUpdateOneRequiredInput
}

input ResultUpdateInput {
  rpe: Int
  compResult: Int
  sessionResult: String
  athlete: AthleteUpdateOneRequiredInput
}

input ResultUpdateManyMutationInput {
  rpe: Int
  compResult: Int
  sessionResult: String
}

input ResultUpdateOneRequiredInput {
  create: ResultCreateInput
  update: ResultUpdateDataInput
  upsert: ResultUpsertNestedInput
  connect: ResultWhereUniqueInput
}

input ResultUpsertNestedInput {
  update: ResultUpdateDataInput!
  create: ResultCreateInput!
}

input ResultWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rpe: Int
  rpe_not: Int
  rpe_in: [Int!]
  rpe_not_in: [Int!]
  rpe_lt: Int
  rpe_lte: Int
  rpe_gt: Int
  rpe_gte: Int
  compResult: Int
  compResult_not: Int
  compResult_in: [Int!]
  compResult_not_in: [Int!]
  compResult_lt: Int
  compResult_lte: Int
  compResult_gt: Int
  compResult_gte: Int
  sessionResult: String
  sessionResult_not: String
  sessionResult_in: [String!]
  sessionResult_not_in: [String!]
  sessionResult_lt: String
  sessionResult_lte: String
  sessionResult_gt: String
  sessionResult_gte: String
  sessionResult_contains: String
  sessionResult_not_contains: String
  sessionResult_starts_with: String
  sessionResult_not_starts_with: String
  sessionResult_ends_with: String
  sessionResult_not_ends_with: String
  athlete: AthleteWhereInput
  AND: [ResultWhereInput!]
  OR: [ResultWhereInput!]
  NOT: [ResultWhereInput!]
}

input ResultWhereUniqueInput {
  id: ID
}

type Schedule {
  id: ID!
  createdBy: Coach
  createdAt: DateTime!
  team: Team
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
}

type ScheduleConnection {
  pageInfo: PageInfo!
  edges: [ScheduleEdge]!
  aggregate: AggregateSchedule!
}

input ScheduleCreateInput {
  id: ID
  createdBy: CoachCreateOneInput
  team: TeamCreateOneWithoutScheduleInput
  athletes: AthleteCreateManyInput
}

input ScheduleCreateOneWithoutTeamInput {
  create: ScheduleCreateWithoutTeamInput
  connect: ScheduleWhereUniqueInput
}

input ScheduleCreateWithoutTeamInput {
  id: ID
  createdBy: CoachCreateOneInput
  athletes: AthleteCreateManyInput
}

type ScheduleEdge {
  node: Schedule!
  cursor: String!
}

enum ScheduleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
}

type SchedulePreviousValues {
  id: ID!
  createdAt: DateTime!
}

type ScheduleSubscriptionPayload {
  mutation: MutationType!
  node: Schedule
  updatedFields: [String!]
  previousValues: SchedulePreviousValues
}

input ScheduleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScheduleWhereInput
  AND: [ScheduleSubscriptionWhereInput!]
  OR: [ScheduleSubscriptionWhereInput!]
  NOT: [ScheduleSubscriptionWhereInput!]
}

input ScheduleUpdateInput {
  createdBy: CoachUpdateOneInput
  team: TeamUpdateOneWithoutScheduleInput
  athletes: AthleteUpdateManyInput
}

input ScheduleUpdateOneWithoutTeamInput {
  create: ScheduleCreateWithoutTeamInput
  update: ScheduleUpdateWithoutTeamDataInput
  upsert: ScheduleUpsertWithoutTeamInput
  delete: Boolean
  disconnect: Boolean
  connect: ScheduleWhereUniqueInput
}

input ScheduleUpdateWithoutTeamDataInput {
  createdBy: CoachUpdateOneInput
  athletes: AthleteUpdateManyInput
}

input ScheduleUpsertWithoutTeamInput {
  update: ScheduleUpdateWithoutTeamDataInput!
  create: ScheduleCreateWithoutTeamInput!
}

input ScheduleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdBy: CoachWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  team: TeamWhereInput
  athletes_every: AthleteWhereInput
  athletes_some: AthleteWhereInput
  athletes_none: AthleteWhereInput
  AND: [ScheduleWhereInput!]
  OR: [ScheduleWhereInput!]
  NOT: [ScheduleWhereInput!]
}

input ScheduleWhereUniqueInput {
  id: ID
}

type Subscription {
  athlete(where: AthleteSubscriptionWhereInput): AthleteSubscriptionPayload
  athleteStats(where: AthleteStatsSubscriptionWhereInput): AthleteStatsSubscriptionPayload
  coach(where: CoachSubscriptionWhereInput): CoachSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  headCoach(where: HeadCoachSubscriptionWhereInput): HeadCoachSubscriptionPayload
  logItem(where: LogItemSubscriptionWhereInput): LogItemSubscriptionPayload
  parent(where: ParentSubscriptionWhereInput): ParentSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  result(where: ResultSubscriptionWhereInput): ResultSubscriptionPayload
  schedule(where: ScheduleSubscriptionWhereInput): ScheduleSubscriptionPayload
  subTeam(where: SubTeamSubscriptionWhereInput): SubTeamSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  workout(where: WorkoutSubscriptionWhereInput): WorkoutSubscriptionPayload
}

type SubTeam {
  id: ID!
  headCoach: HeadCoach!
  ahtletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  coahces(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach!]
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
}

type SubTeamConnection {
  pageInfo: PageInfo!
  edges: [SubTeamEdge]!
  aggregate: AggregateSubTeam!
}

input SubTeamCreateInput {
  id: ID
  headCoach: HeadCoachCreateOneInput!
  ahtletes: AthleteCreateManyInput
  coahces: CoachCreateManyWithoutTeamsInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

input SubTeamCreateManyInput {
  create: [SubTeamCreateInput!]
  connect: [SubTeamWhereUniqueInput!]
}

input SubTeamCreateManyWithoutCoahcesInput {
  create: [SubTeamCreateWithoutCoahcesInput!]
  connect: [SubTeamWhereUniqueInput!]
}

input SubTeamCreateWithoutCoahcesInput {
  id: ID
  headCoach: HeadCoachCreateOneInput!
  ahtletes: AthleteCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
}

type SubTeamEdge {
  node: SubTeam!
  cursor: String!
}

enum SubTeamOrderByInput {
  id_ASC
  id_DESC
}

type SubTeamPreviousValues {
  id: ID!
}

input SubTeamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SubTeamScalarWhereInput!]
  OR: [SubTeamScalarWhereInput!]
  NOT: [SubTeamScalarWhereInput!]
}

type SubTeamSubscriptionPayload {
  mutation: MutationType!
  node: SubTeam
  updatedFields: [String!]
  previousValues: SubTeamPreviousValues
}

input SubTeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubTeamWhereInput
  AND: [SubTeamSubscriptionWhereInput!]
  OR: [SubTeamSubscriptionWhereInput!]
  NOT: [SubTeamSubscriptionWhereInput!]
}

input SubTeamUpdateDataInput {
  headCoach: HeadCoachUpdateOneRequiredInput
  ahtletes: AthleteUpdateManyInput
  coahces: CoachUpdateManyWithoutTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateInput {
  headCoach: HeadCoachUpdateOneRequiredInput
  ahtletes: AthleteUpdateManyInput
  coahces: CoachUpdateManyWithoutTeamsInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateManyInput {
  create: [SubTeamCreateInput!]
  update: [SubTeamUpdateWithWhereUniqueNestedInput!]
  upsert: [SubTeamUpsertWithWhereUniqueNestedInput!]
  delete: [SubTeamWhereUniqueInput!]
  connect: [SubTeamWhereUniqueInput!]
  set: [SubTeamWhereUniqueInput!]
  disconnect: [SubTeamWhereUniqueInput!]
  deleteMany: [SubTeamScalarWhereInput!]
}

input SubTeamUpdateManyWithoutCoahcesInput {
  create: [SubTeamCreateWithoutCoahcesInput!]
  delete: [SubTeamWhereUniqueInput!]
  connect: [SubTeamWhereUniqueInput!]
  set: [SubTeamWhereUniqueInput!]
  disconnect: [SubTeamWhereUniqueInput!]
  update: [SubTeamUpdateWithWhereUniqueWithoutCoahcesInput!]
  upsert: [SubTeamUpsertWithWhereUniqueWithoutCoahcesInput!]
  deleteMany: [SubTeamScalarWhereInput!]
}

input SubTeamUpdateWithoutCoahcesDataInput {
  headCoach: HeadCoachUpdateOneRequiredInput
  ahtletes: AthleteUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
}

input SubTeamUpdateWithWhereUniqueNestedInput {
  where: SubTeamWhereUniqueInput!
  data: SubTeamUpdateDataInput!
}

input SubTeamUpdateWithWhereUniqueWithoutCoahcesInput {
  where: SubTeamWhereUniqueInput!
  data: SubTeamUpdateWithoutCoahcesDataInput!
}

input SubTeamUpsertWithWhereUniqueNestedInput {
  where: SubTeamWhereUniqueInput!
  update: SubTeamUpdateDataInput!
  create: SubTeamCreateInput!
}

input SubTeamUpsertWithWhereUniqueWithoutCoahcesInput {
  where: SubTeamWhereUniqueInput!
  update: SubTeamUpdateWithoutCoahcesDataInput!
  create: SubTeamCreateWithoutCoahcesInput!
}

input SubTeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  headCoach: HeadCoachWhereInput
  ahtletes_every: AthleteWhereInput
  ahtletes_some: AthleteWhereInput
  ahtletes_none: AthleteWhereInput
  coahces_every: CoachWhereInput
  coahces_some: CoachWhereInput
  coahces_none: CoachWhereInput
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  AND: [SubTeamWhereInput!]
  OR: [SubTeamWhereInput!]
  NOT: [SubTeamWhereInput!]
}

input SubTeamWhereUniqueInput {
  id: ID
}

type Team {
  id: ID!
  teamName: String!
  headCoach: HeadCoach
  athletes(where: AthleteWhereInput, orderBy: AthleteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Athlete!]
  coahces(where: CoachWhereInput, orderBy: CoachOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Coach!]
  subTeams(where: SubTeamWhereInput, orderBy: SubTeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubTeam!]
  library(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout!]
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  schedule: Schedule
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  coahces: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: ScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateOneWithoutAthletesInput {
  create: TeamCreateWithoutAthletesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutCoahcesInput {
  create: TeamCreateWithoutCoahcesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutHeadCoachInput {
  create: TeamCreateWithoutHeadCoachInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutScheduleInput {
  create: TeamCreateWithoutScheduleInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAthletesInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  coahces: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: ScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutCoahcesInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: ScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutHeadCoachInput {
  id: ID
  teamName: String!
  athletes: AthleteCreateManyWithoutTeamInput
  coahces: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  schedule: ScheduleCreateOneWithoutTeamInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

input TeamCreateWithoutScheduleInput {
  id: ID
  teamName: String!
  headCoach: HeadCoachCreateOneWithoutTeamInput
  athletes: AthleteCreateManyWithoutTeamInput
  coahces: CoachCreateManyWithoutTeamInput
  subTeams: SubTeamCreateManyInput
  library: WorkoutCreateManyInput
  posts: PostCreateManyInput
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  teamName_ASC
  teamName_DESC
  phase_ASC
  phase_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  homeGym_ASC
  homeGym_DESC
  teamKey_ASC
  teamKey_DESC
  coachKey_ASC
  coachKey_DESC
}

type TeamPreviousValues {
  id: ID!
  teamName: String!
  phase: String
  city: String!
  state: String!
  homeGym: String!
  teamKey: String
  coachKey: String
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coahces: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: ScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateManyMutationInput {
  teamName: String
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateOneWithoutAthletesInput {
  create: TeamCreateWithoutAthletesInput
  update: TeamUpdateWithoutAthletesDataInput
  upsert: TeamUpsertWithoutAthletesInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutCoahcesInput {
  create: TeamCreateWithoutCoahcesInput
  update: TeamUpdateWithoutCoahcesDataInput
  upsert: TeamUpsertWithoutCoahcesInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutHeadCoachInput {
  create: TeamCreateWithoutHeadCoachInput
  update: TeamUpdateWithoutHeadCoachDataInput
  upsert: TeamUpsertWithoutHeadCoachInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneWithoutScheduleInput {
  create: TeamCreateWithoutScheduleInput
  update: TeamUpdateWithoutScheduleDataInput
  upsert: TeamUpsertWithoutScheduleInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutAthletesDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  coahces: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: ScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutCoahcesDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: ScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutHeadCoachDataInput {
  teamName: String
  athletes: AthleteUpdateManyWithoutTeamInput
  coahces: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  schedule: ScheduleUpdateOneWithoutTeamInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpdateWithoutScheduleDataInput {
  teamName: String
  headCoach: HeadCoachUpdateOneWithoutTeamInput
  athletes: AthleteUpdateManyWithoutTeamInput
  coahces: CoachUpdateManyWithoutTeamInput
  subTeams: SubTeamUpdateManyInput
  library: WorkoutUpdateManyInput
  posts: PostUpdateManyInput
  phase: String
  city: String
  state: String
  homeGym: String
  teamKey: String
  coachKey: String
}

input TeamUpsertWithoutAthletesInput {
  update: TeamUpdateWithoutAthletesDataInput!
  create: TeamCreateWithoutAthletesInput!
}

input TeamUpsertWithoutCoahcesInput {
  update: TeamUpdateWithoutCoahcesDataInput!
  create: TeamCreateWithoutCoahcesInput!
}

input TeamUpsertWithoutHeadCoachInput {
  update: TeamUpdateWithoutHeadCoachDataInput!
  create: TeamCreateWithoutHeadCoachInput!
}

input TeamUpsertWithoutScheduleInput {
  update: TeamUpdateWithoutScheduleDataInput!
  create: TeamCreateWithoutScheduleInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  teamName: String
  teamName_not: String
  teamName_in: [String!]
  teamName_not_in: [String!]
  teamName_lt: String
  teamName_lte: String
  teamName_gt: String
  teamName_gte: String
  teamName_contains: String
  teamName_not_contains: String
  teamName_starts_with: String
  teamName_not_starts_with: String
  teamName_ends_with: String
  teamName_not_ends_with: String
  headCoach: HeadCoachWhereInput
  athletes_every: AthleteWhereInput
  athletes_some: AthleteWhereInput
  athletes_none: AthleteWhereInput
  coahces_every: CoachWhereInput
  coahces_some: CoachWhereInput
  coahces_none: CoachWhereInput
  subTeams_every: SubTeamWhereInput
  subTeams_some: SubTeamWhereInput
  subTeams_none: SubTeamWhereInput
  library_every: WorkoutWhereInput
  library_some: WorkoutWhereInput
  library_none: WorkoutWhereInput
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  schedule: ScheduleWhereInput
  phase: String
  phase_not: String
  phase_in: [String!]
  phase_not_in: [String!]
  phase_lt: String
  phase_lte: String
  phase_gt: String
  phase_gte: String
  phase_contains: String
  phase_not_contains: String
  phase_starts_with: String
  phase_not_starts_with: String
  phase_ends_with: String
  phase_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  homeGym: String
  homeGym_not: String
  homeGym_in: [String!]
  homeGym_not_in: [String!]
  homeGym_lt: String
  homeGym_lte: String
  homeGym_gt: String
  homeGym_gte: String
  homeGym_contains: String
  homeGym_not_contains: String
  homeGym_starts_with: String
  homeGym_not_starts_with: String
  homeGym_ends_with: String
  homeGym_not_ends_with: String
  teamKey: String
  teamKey_not: String
  teamKey_in: [String!]
  teamKey_not_in: [String!]
  teamKey_lt: String
  teamKey_lte: String
  teamKey_gt: String
  teamKey_gte: String
  teamKey_contains: String
  teamKey_not_contains: String
  teamKey_starts_with: String
  teamKey_not_starts_with: String
  teamKey_ends_with: String
  teamKey_not_ends_with: String
  coachKey: String
  coachKey_not: String
  coachKey_in: [String!]
  coachKey_not_in: [String!]
  coachKey_lt: String
  coachKey_lte: String
  coachKey_gt: String
  coachKey_gte: String
  coachKey_contains: String
  coachKey_not_contains: String
  coachKey_starts_with: String
  coachKey_not_starts_with: String
  coachKey_ends_with: String
  coachKey_not_ends_with: String
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}

type Workout {
  id: ID!
  author: String!
  title: String!
  description: String!
}

type WorkoutConnection {
  pageInfo: PageInfo!
  edges: [WorkoutEdge]!
  aggregate: AggregateWorkout!
}

input WorkoutCreateInput {
  id: ID
  author: String!
  title: String!
  description: String!
}

input WorkoutCreateManyInput {
  create: [WorkoutCreateInput!]
  connect: [WorkoutWhereUniqueInput!]
}

type WorkoutEdge {
  node: Workout!
  cursor: String!
}

enum WorkoutOrderByInput {
  id_ASC
  id_DESC
  author_ASC
  author_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
}

type WorkoutPreviousValues {
  id: ID!
  author: String!
  title: String!
  description: String!
}

input WorkoutScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: String
  author_not: String
  author_in: [String!]
  author_not_in: [String!]
  author_lt: String
  author_lte: String
  author_gt: String
  author_gte: String
  author_contains: String
  author_not_contains: String
  author_starts_with: String
  author_not_starts_with: String
  author_ends_with: String
  author_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [WorkoutScalarWhereInput!]
  OR: [WorkoutScalarWhereInput!]
  NOT: [WorkoutScalarWhereInput!]
}

type WorkoutSubscriptionPayload {
  mutation: MutationType!
  node: Workout
  updatedFields: [String!]
  previousValues: WorkoutPreviousValues
}

input WorkoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutWhereInput
  AND: [WorkoutSubscriptionWhereInput!]
  OR: [WorkoutSubscriptionWhereInput!]
  NOT: [WorkoutSubscriptionWhereInput!]
}

input WorkoutUpdateDataInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyDataInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyInput {
  create: [WorkoutCreateInput!]
  update: [WorkoutUpdateWithWhereUniqueNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueNestedInput!]
  delete: [WorkoutWhereUniqueInput!]
  connect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
}

input WorkoutUpdateManyMutationInput {
  author: String
  title: String
  description: String
}

input WorkoutUpdateManyWithWhereNestedInput {
  where: WorkoutScalarWhereInput!
  data: WorkoutUpdateManyDataInput!
}

input WorkoutUpdateWithWhereUniqueNestedInput {
  where: WorkoutWhereUniqueInput!
  data: WorkoutUpdateDataInput!
}

input WorkoutUpsertWithWhereUniqueNestedInput {
  where: WorkoutWhereUniqueInput!
  update: WorkoutUpdateDataInput!
  create: WorkoutCreateInput!
}

input WorkoutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: String
  author_not: String
  author_in: [String!]
  author_not_in: [String!]
  author_lt: String
  author_lte: String
  author_gt: String
  author_gte: String
  author_contains: String
  author_not_contains: String
  author_starts_with: String
  author_not_starts_with: String
  author_ends_with: String
  author_not_ends_with: String
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  NOT: [WorkoutWhereInput!]
}

input WorkoutWhereUniqueInput {
  id: ID
}
`
      }
    